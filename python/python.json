{
  "python_print": {
    "prefix": "print",
    "body": [
      "print(\"$1\")"
    ],
    "description": "Afficher du texte"
  },
  "python_input": {
    "prefix": "input",
    "body": [
      "$1 = input(\"$2\")"
    ],
    "description": "Lire une entrée utilisateur"
  },
  "python_if": {
    "prefix": "if",
    "body": [
      "if $1:",
      "    $2"
    ],
    "description": "Condition if"
  },
  "python_if_else": {
    "prefix": "if else",
    "body": [
      "if $1:",
      "    $2",
      "else:",
      "    $3"
    ],
    "description": "Condition if/else"
  },
  "python_elif": {
    "prefix": "elif",
    "body": [
      "if $1:",
      "    $2",
      "elif $3:",
      "    $4",
      "else:",
      "    $5"
    ],
    "description": "Condition if/elif/else"
  },
  "python_for_loop": {
    "prefix": "for",
    "body": [
      "for $1 in $2:",
      "    $3"
    ],
    "description": "Boucle for"
  },
  "python_while_loop": {
    "prefix": "while",
    "body": [
      "while $1:",
      "    $2"
    ],
    "description": "Boucle while"
  },
  "python_function": {
    "prefix": "def",
    "body": [
      "def $1($2):",
      "    $3"
    ],
    "description": "Définir une fonction"
  },
  "python_class": {
    "prefix": "class",
    "body": [
      "class $1:",
      "    def __init__(self, $2):",
      "        $3"
    ],
    "description": "Définir une classe"
  },
  "python_list": {
    "prefix": "list",
    "body": [
      "$1 = [$2]"
    ],
    "description": "Créer une liste"
  },
  "python_dict": {
    "prefix": "dict",
    "body": [
      "$1 = {\"$2\": $3}"
    ],
    "description": "Créer un dictionnaire"
  },
  "python_try_except": {
    "prefix": "try",
    "body": [
      "try:",
      "    $1",
      "except $2 as e:",
      "    print(e)"
    ],
    "description": "Bloc try/except"
  },
  "verification_presence": {
    "prefix": ".srt in ",
    "body": [
      "\"$1\" in s"
    ],
    "description": "Vérifier si une sous-chaîne est présente"
  },
  "verification_absence": {
    "prefix": ".srt notin ",
    "body": [
      "\"$1\" not in s"
    ],
    "description": "Vérifier si une sous-chaîne est absente"
  },
  "remplacement_mot": {
    "prefix": ".srt replace ",
    "body": [
      "s = .replace(\"$1\", \"$2\") ",
      "print(s) "
    ],
    "description": "Remplacement d'un mot dans une chaîne"
  },
  "majuscule": {
    "prefix": ".srt upper ",
    "body": [
      ".upper() "
    ],
    "description": "Convertir en majuscules"
  },
  "minuscule": {
    "prefix": ".srt lower ",
    "body": [
      ".lower() "
    ],
    "description": "Convertir en minuscules"
  },
  "premiere_lettre_majuscule": {
    "prefix": ".srt capitalize ",
    "body": [
      ".capitalize() "
    ],
    "description": "Mettre la première lettre en majuscule"
  },
  "titre": {
    "prefix": ".srt title ",
    "body": [
      ".title() "
    ],
    "description": "Mettre la première lettre de chaque mot en majuscule"
  },
  "suppression_espaces": {
    "prefix": ".srt strip ",
    "body": [
      ".strip() "
    ],
    "description": "Supprimer les espaces autour d'une chaîne"
  },
  "suppression_espaces_gauche": {
    "prefix": ".srt lstrip ",
    "body": [
      ".lstrip() "
    ],
    "description": "Supprimer les espaces à gauche"
  },
  "suppression_espaces_droite": {
    "prefix": ".srt rstrip ",
    "body": [
      ".rstrip() "
    ],
    "description": "Supprimer les espaces à droite"
  },
  "separation_chaine": {
    "prefix": ".srt split ",
    "body": [
      ".split(\"$1\") "
    ],
    "description": "Séparer une chaîne en liste"
  },
  "jointure_chaines": {
    "prefix": ".srt join ",
    "body": [
      "\"$1\".join($2) "
    ],
    "description": "Joindre une liste en une chaîne"
  },
  "trouver_sous_chaine": {
    "prefix": ".srt find ",
    "body": [
      ".find(\"$1\") "
    ],
    "description": "Trouver une sous-chaîne"
  },
  "compter_occurrences": {
    "prefix": ".srt count ",
    "body": [
      ".count(\"$1\") "
    ],
    "description": "Compter les occurrences d'une sous-chaîne"
  },
  "verifier_debut": {
    "prefix": ".srt startswith ",
    "body": [
      ".startswith(\"$1\") "
    ],
    "description": "Vérifier si une chaîne commence par un mot"
  },
  "verifier_fin": {
    "prefix": ".srt endswith ",
    "body": [
      ".endswith(\"$1\") "
    ],
    "description": "Vérifier si une chaîne se termine par un mot"
  },
  "formatage_chaines": {
    "prefix": ".srt format ",
    "body": [
      "f\"{s} {variable}\""
    ],
    "description": "Formatage de chaîne"
  },
  "inversion_chaine": {
    "prefix": ".srt reverse ",
    "body": [
      "s[::-1] "
    ],
    "description": "Inverser une chaîne"
  },
  "verifier_chiffre": {
    "prefix": ".srt isdigit ",
    "body": [
      ".isdigit() "
    ],
    "description": "Vérifier si la chaîne ne contient que des chiffres"
  },
  "verifier_alpha": {
    "prefix": ".srt isalpha ",
    "body": [
      ".isalpha() "
    ],
    "description": "Vérifier si la chaîne ne contient que des lettres"
  },
  "verifier_alphanum": {
    "prefix": ".srt isalnum ",
    "body": [
      ".isalnum() "
    ],
    "description": "Vérifier si la chaîne contient des lettres et/ou chiffres"
  },
  "verifier_espace": {
    "prefix": ".srt isspace ",
    "body": [
      ".isspace() "
    ],
    "description": "Vérifier si la chaîne ne contient que des espaces"
  },
  "alignement_centre": {
    "prefix": ".srt center ",
    "body": [
      ".center($1, \"$2\") "
    ],
    "description": "Aligner le texte au centre"
  },
  "alignement_gauche": {
    "prefix": ".srt ljust ",
    "body": [
      ".ljust($1, \"$2\") "
    ],
    "description": "Aligner le texte à gauche"
  },
  "alignement_droite": {
    "prefix": ".srt rjust ",
    "body": [
      ".rjust($1, \"$2\") "
    ],
    "description": "Aligner le texte à droite"
  },
  "suppression_caracteres_specifiques": {
    "prefix": ".srt trim ",
    "body": [
      ".strip(\"$1\") "
    ],
    "description": "Supprimer un caractère spécifique d'une chaîne"
  },
  "conversion_liste_chaine": {
    "prefix": ".srt list_to_str ",
    "body": [
      "\"\".join($1) "
    ],
    "description": "Convertir une liste en chaîne"
  },
  "conversion_ascii": {
    "prefix": ".srt ord ",
    "body": [
      "ord(\"$1\") "
    ],
    "description": "Obtenir le code ASCII d'un caractère"
  },
  "conversion_unicode": {
    "prefix": ".srt chr ",
    "body": [
      "chr($1) "
    ],
    "description": "Convertir un code ASCII en caractère"
  },
  "ajout_zeroes": {
    "prefix": ".srt zfill ",
    "body": [
      ".zfill($1) "
    ],
    "description": "Ajouter des zéros devant une chaîne"
  },
  "expression_reguliere": {
    "prefix": ".srt regex ",
    "body": [
      "import re",
      "match = re.search(r\"$1\", s)",
      "if match:",
      "    print(match.group())"
    ],
    "description": "Recherche avec une expression régulière"
  },
  "remplacement_regex": {
    "prefix": ".srt regex_replace ",
    "body": [
      "s = re.sub(r\"$1\", \"$2\", s) "
    ],
    "description": "Remplacement avec une regex"
  },
  "fractionnement_regex": {
    "prefix": ".srt regex_split ",
    "body": [
      "re.split(r\"$1\", s) "
    ],
    "description": "Fractionner une chaîne avec une regex"
  },
  "verifier_palindrome": {
    "prefix": ".srt palindrome ",
    "body": [
      "s == s[::-1] "
    ],
    "description": "Vérifier si une chaîne est un palindrome"
  },
  "echapper_caracteres": {
    "prefix": ".srt escape ",
    "body": [
      "s = .replace(\"\\\"\", \"\\\\\\\"\")"
    ],
    "description": "Échapper des caractères spéciaux"
  },
  "Ajout d'un élément au tableau": {
    "prefix": ".array append",
    "body": [
      ".append('$1')"
    ],
    "description": "Ajoute un élément à la fin de la liste"
  },
  "Insertion dans un tableau": {
    "prefix": ".array insert",
    "body": [
      ".insert($1, '$2')"
    ],
    "description": "Insère un élément à une position spécifique de la liste"
  },
  "Suppression d'un élément": {
    "prefix": ".array remove",
    "body": [
      ".remove('$1')"
    ],
    "description": "Supprime la première occurrence d'un élément de la liste"
  },
  "Suppression par index": {
    "prefix": ".array pop",
    "body": [
      ".pop($1)"
    ],
    "description": "Supprime et renvoie un élément à une position spécifique"
  },
  "Fusion de listes": {
    "prefix": ".array extend",
    "body": [
      ".extend($1)"
    ],
    "description": "Ajoute tous les éléments d'un autre tableau à la fin"
  },
  "Recherche d'index": {
    "prefix": ".array index",
    "body": [
      ".index('$1')"
    ],
    "description": "Trouve l'index de la première occurrence d'un élément"
  },
  "Comptage d'éléments": {
    "prefix": ".array count",
    "body": [
      ".count('$1')"
    ],
    "description": "Compte le nombre d'occurrences d'un élément dans la liste"
  },
  "Tri d'une liste": {
    "prefix": ".array sort",
    "body": [
      ".sort()"
    ],
    "description": "Trie la liste en ordre croissant"
  },
  "Inversion d'une liste": {
    "prefix": ".array reverse",
    "body": [
      ".reverse()"
    ],
    "description": "Inverse l'ordre des éléments dans la liste"
  },
  "Longueur d'une liste": {
    "prefix": ".array len",
    "body": [
      "len()"
    ],
    "description": "Renvoie la longueur de la liste"
  },
  "Suppression de tous les éléments": {
    "prefix": ".array clear",
    "body": [
      ".clear()"
    ],
    "description": "Supprime tous les éléments de la liste"
  },
  "Copie d'une liste": {
    "prefix": ".array copy",
    "body": [
      ".copy()"
    ],
    "description": "Crée une copie de la liste"
  },
  "Valeur minimale": {
    "prefix": ".array min",
    "body": [
      "min()"
    ],
    "description": "Trouve la valeur minimale dans la liste"
  },
  "Valeur maximale": {
    "prefix": ".array max",
    "body": [
      "max()"
    ],
    "description": "Trouve la valeur maximale dans la liste"
  },
  "Somme des éléments": {
    "prefix": ".array sum",
    "body": [
      "sum()"
    ],
    "description": "Calcule la somme des éléments de la liste"
  },
  "Extraction d'une portion": {
    "prefix": ".array slice",
    "body": [
      "array[$1:$2]"
    ],
    "description": "Extrait une portion de la liste (slicing)"
  },
  "Vérification 'tous les éléments'": {
    "prefix": ".array all",
    "body": [
      "all()"
    ],
    "description": "Vérifie si tous les éléments satisfont une condition"
  },
  "Vérification 'au moins un élément'": {
    "prefix": ".array any",
    "body": [
      "any()"
    ],
    "description": "Vérifie si au moins un élément satisfait une condition"
  },
  "Association de deux listes": {
    "prefix": ".array zip",
    "body": [
      "list(zip($1, $2))"
    ],
    "description": "Combine deux listes élément par élément"
  },
  "Application d'une fonction": {
    "prefix": ".array map",
    "body": [
      "list(map($1,$2 ))"
    ],
    "description": "Applique une fonction à chaque élément de la liste"
  },
  "Filtrage d'une liste": {
    "prefix": ".array filter",
    "body": [
      "list(filter($1, $2))"
    ],
    "description": "Filtre les éléments de la liste selon une condition"
  },
  "racine_carre": {
    "prefix": ".math sqrt ",
    "body": [
      "math.sqrt($1)"
    ],
    "description": "Calculer la racine carrée d'un nombre"
  },
  "addition": {
    "prefix": ".math add ",
    "body": [
      "$1 + $2"
    ],
    "description": "Additionner deux nombres"
  },
  "soustraction": {
    "prefix": ".math subtract ",
    "body": [
      "$1 - $2"
    ],
    "description": "Soustraire deux nombres"
  },
  "multiplication": {
    "prefix": ".math multiply ",
    "body": [
      "$1 * $2"
    ],
    "description": "Multiplier deux nombres"
  },
  "division": {
    "prefix": ".math divide ",
    "body": [
      "$1 / $2"
    ],
    "description": "Diviser deux nombres"
  },
  "puissance": {
    "prefix": ".math power ",
    "body": [
      "$1 ** $2"
    ],
    "description": "Élever un nombre à une puissance"
  },
  "valeur_absolue": {
    "prefix": ".math abs ",
    "body": [
      "abs($1)"
    ],
    "description": "Calculer la valeur absolue d'un nombre"
  },
  "arrondi": {
    "prefix": ".math round ",
    "body": [
      "round($1, $2)"
    ],
    "description": "Arrondir un nombre à un certain nombre de décimales"
  },
  "arrondi_inférieur": {
    "prefix": ".math floor ",
    "body": [
      "math.floor($1)"
    ],
    "description": "Arrondir un nombre à l'entier inférieur le plus proche"
  },
  "arrondi_supérieur": {
    "prefix": ".math ceil ",
    "body": [
      "math.ceil($1)"
    ],
    "description": "Arrondir un nombre à l'entier supérieur le plus proche"
  },
  "maximum": {
    "prefix": ".math max ",
    "body": [
      "max($1, $2)"
    ],
    "description": "Trouver la valeur maximale parmi plusieurs nombres"
  },
  "minimum": {
    "prefix": ".math min ",
    "body": [
      "min($1, $2)"
    ],
    "description": "Trouver la valeur minimale parmi plusieurs nombres"
  },
  "somme": {
    "prefix": ".math sum ",
    "body": [
      "sum($1)"
    ],
    "description": "Calculer la somme d'une liste de nombres"
  },
  "moyenne": {
    "prefix": ".math average ",
    "body": [
      "sum($1) / len($1)"
    ],
    "description": "Calculer la moyenne d'une liste de nombres"
  },
  "modulo": {
    "prefix": ".math mod ",
    "body": [
      "$1 % $2"
    ],
    "description": "Calculer le reste de la division entre deux nombres"
  },
  "pi": {
    "prefix": ".math pi ",
    "body": [
      "math.pi"
    ],
    "description": "Obtenir la valeur de Pi"
  },
  "sinus": {
    "prefix": ".math sin ",
    "body": [
      "math.sin($1)"
    ],
    "description": "Calculer le sinus d'un angle (en radians)"
  },
  "cosinus": {
    "prefix": ".math cos ",
    "body": [
      "math.cos($1)"
    ],
    "description": "Calculer le cosinus d'un angle (en radians)"
  },
  "tangente": {
    "prefix": ".math tan ",
    "body": [
      "math.tan($1)"
    ],
    "description": "Calculer la tangente d'un angle (en radians)"
  },
  "radians": {
    "prefix": ".math radians ",
    "body": [
      "math.radians($1)"
    ],
    "description": "Convertir un angle en degrés en radians"
  },
  "degres": {
    "prefix": ".math degrees ",
    "body": [
      "math.degrees($1)"
    ],
    "description": "Convertir un angle en radians en degrés"
  },
  "logarithme": {
    "prefix": ".math log ",
    "body": [
      "math.log($1, $2)"
    ],
    "description": "Calculer le logarithme d'un nombre"
  },
  "tkinter_setup": {
    "prefix": ".tk setup",
    "body": [
      "import tkinter as tk",
      "root = tk.Tk()",
      "root.title('$1')",
      "root.geometry('$2')",
      "root.mainloop()"
    ],
    "description": "Initialiser une application Tkinter"
  },
  "tkinter_button": {
    "prefix": ".tk btn",
    "body": [
      "btn = tk.Button(root, text='$1', command=$2)",
      "btn.pack()"
    ],
    "description": "Créer un bouton Tkinter"
  },
  "tkinter_label": {
    "prefix": ".tk label",
    "body": [
      "label = tk.Label(root, text='$1')",
      "label.pack()"
    ],
    "description": "Créer une étiquette Tkinter"
  },
  "tkinter_entry": {
    "prefix": ".tk entry",
    "body": [
      "entry = tk.Entry(root)",
      "entry.pack()"
    ],
    "description": "Créer un champ de saisie Tkinter"
  },
  "tkinter_scale": {
    "prefix": ".tk scale",
    "body": [
      "scale = tk.Scale(root, from_=$1, to=$2, orient='$3')",
      "scale.pack()"
    ],
    "description": "Créer une échelle Tkinter"
  },
  "tkinter_checkbox": {
    "prefix": ".tk checkbox",
    "body": [
      "var = tk.IntVar()",
      "checkbox = tk.Checkbutton(root, text='$1', variable=var)",
      "checkbox.pack()"
    ],
    "description": "Créer une case à cocher Tkinter"
  },
  "tkinter_radiobutton": {
    "prefix": ".tk radiobutton",
    "body": [
      "var = tk.StringVar()",
      "radiobutton = tk.Radiobutton(root, text='$1', variable=var, value='$2')",
      "radiobutton.pack()"
    ],
    "description": "Créer un bouton radio Tkinter"
  },
  "tkinter_listbox": {
    "prefix": ".tk listbox",
    "body": [
      "listbox = tk.Listbox(root)",
      "listbox.pack()"
    ],
    "description": "Créer une liste Tkinter"
  },
  "tkinter_canvas": {
    "prefix": ".tk canvas",
    "body": [
      "canvas = tk.Canvas(root, width=$1, height=$2)",
      "canvas.pack()"
    ],
    "description": "Créer un canevas Tkinter"
  },
  "tkinter_menu": {
    "prefix": ".tk menu",
    "body": [
      "menu = tk.Menu(root)",
      "root.config(menu=menu)",
      "submenu = tk.Menu(menu)",
      "menu.add_cascade(label='$1', menu=submenu)",
      "submenu.add_command(label='$2', command=$3)"
    ],
    "description": "Créer un menu Tkinter"
  },
  "tkinter_scrollbar": {
    "prefix": ".tk scrollbar",
    "body": [
      "scrollbar = tk.Scrollbar(root)",
      "scrollbar.pack(side=tk.RIGHT, fill=tk.Y)"
    ],
    "description": "Créer une barre de défilement Tkinter"
  },
  "tkinter_text": {
    "prefix": ".tk text",
    "body": [
      "text = tk.Text(root)",
      "text.pack()"
    ],
    "description": "Créer un widget de texte Tkinter"
  },
  "tkinter_combobox": {
    "prefix": ".tk combobox",
    "body": [
      "from tkinter import ttk",
      "combobox = ttk.Combobox(root, values=['$1', '$2', '$3'])",
      "combobox.pack()"
    ],
    "description": "Créer une boîte combinée Tkinter"
  },
  "tkinter_messagebox": {
    "prefix": ".tk messagebox",
    "body": [
      "from tkinter import messagebox",
      "messagebox.showinfo('$1', '$2')"
    ],
    "description": "Afficher une boîte de message Tkinter"
  },
  "tkinter_file_dialog": {
    "prefix": ".tk file dialog",
    "body": [
      "from tkinter import filedialog",
      "file_path = filedialog.askopenfilename()"
    ],
    "description": "Ouvrir une boîte de dialogue de fichier Tkinter"
  },
  "tkinter_menu_bar": {
    "prefix": ".tk menu bar",
    "body": [
      "menu_bar = tk.Menu(root)",
      "file_menu = tk.Menu(menu_bar, tearoff=0)",
      "file_menu.add_command(label='Open', command=$1)",
      "file_menu.add_command(label='Save', command=$2)",
      "file_menu.add_separator()",
      "file_menu.add_command(label='Exit', command=root.quit)",
      "menu_bar.add_cascade(label='File', menu=file_menu)",
      "root.config(menu=menu_bar)"
    ],
    "description": "Créer une barre de menu Tkinter"
  },
  "tkinter_canvas_draw": {
    "prefix": ".tk canvas draw",
    "body": [
      "canvas = tk.Canvas(root, width=$1, height=$2)",
      "canvas.pack()",
      "canvas.create_rectangle($3, $4, $5, $6, fill='$7')"
    ],
    "description": "Dessiner sur un canevas Tkinter"
  },
  "tkinter_grid_layout": {
    "prefix": ".tk grid",
    "body": [
      "label = tk.Label(root, text='$1')",
      "label.grid(row=$2, column=$3)",
      "entry = tk.Entry(root)",
      "entry.grid(row=$4, column=$5)"
    ],
    "description": "Utiliser un gestionnaire de grille Tkinter"
  },
  "tkinter_pack_layout": {
    "prefix": ".tk pack",
    "body": [
      "label = tk.Label(root, text='$1')",
      "label.pack(side=tk.$2)"
    ],
    "description": "Utiliser un gestionnaire de pack Tkinter"
  },
  "tkinter_place_layout": {
    "prefix": ".tk place",
    "body": [
      "label = tk.Label(root, text='$1')",
      "label.place(x=$2, y=$3)"
    ],
    "description": "Utiliser un gestionnaire de placement Tkinter"
  },
  "tkinter_frame": {
    "prefix": ".tk frame",
    "body": [
      "frame = tk.Frame(root, width=$1, height=$2, bg='$3')",
      "frame.pack()"
    ],
    "description": "Créer un cadre Tkinter"
  },
  "tkinter_radio_group": {
    "prefix": ".tk radio group",
    "body": [
      "var = tk.StringVar()",
      "radio1 = tk.Radiobutton(root, text='$1', variable=var, value='$2')",
      "radio2 = tk.Radiobutton(root, text='$3', variable=var, value='$4')",
      "radio1.pack()",
      "radio2.pack()"
    ],
    "description": "Créer un groupe de boutons radio Tkinter"
  },
  "tkinter_progressbar": {
    "prefix": ".tk progressbar",
    "body": [
      "from tkinter.ttk import Progressbar",
      "progress = Progressbar(root, orient='$1', length=$2, mode='$3')",
      "progress.pack()"
    ],
    "description": "Créer une barre de progression Tkinter"
  },
  "tkinter_spinbox": {
    "prefix": ".tk spinbox",
    "body": [
      "spinbox = tk.Spinbox(root, from_=$1, to=$2)",
      "spinbox.pack()"
    ],
    "description": "Créer une boîte de sélection Tkinter"
  },
  "tkinter_scrollable_text": {
    "prefix": ".tk scrollable text",
    "body": [
      "from tkinter import scrolledtext",
      "scroll_text = scrolledtext.ScrolledText(root, width=$1, height=$2)",
      "scroll_text.pack()"
    ],
    "description": "Créer un widget de texte défilable Tkinter"
  },
  "tkinter_canvas_line": {
    "prefix": ".tk canvas line",
    "body": [
      "canvas.create_line($1, $2, $3, $4, fill='$5', width=$6)"
    ],
    "description": "Dessiner une ligne sur un canevas Tkinter"
  },
  "tkinter_canvas_oval": {
    "prefix": ".tk canvas oval",
    "body": [
      "canvas.create_oval($1, $2, $3, $4, fill='$5')"
    ],
    "description": "Dessiner un ovale sur un canevas Tkinter"
  },
  "tkinter_canvas_polygon": {
    "prefix": ".tk canvas polygon",
    "body": [
      "canvas.create_polygon($1, $2, $3, $4, $5, $6, fill='$7')"
    ],
    "description": "Dessiner un polygone sur un canevas Tkinter"
  },
  "tkinter_canvas_text": {
    "prefix": ".tk canvas text",
    "body": [
      "canvas.create_text($1, $2, text='$3', fill='$4', font=('$5', $6))"
    ],
    "description": "Ajouter du texte sur un canevas Tkinter"
  },
  "tkinter_bind_event": {
    "prefix": ".tk bind",
    "body": [
      "def $1(event):",
      "    $2",
      "root.bind('$3', $1)"
    ],
    "description": "Lier un événement à une fonction Tkinter"
  },
  "flet_setup": {
    "prefix": ".flet setup",
    "body": [
      "import flet as ft",
      "def main(page: ft.Page):",
      "    page.title = '$1'",
      "    page.update()",
      "ft.app(target=main)"
    ],
    "description": "Initialiser une application Flet"
  },
  "flet_button": {
    "prefix": ".flet btn",
    "body": [
      "btn = ft.ElevatedButton(text='$1', on_click=$2)",
      "page.add(btn)"
    ],
    "description": "Créer un bouton Flet"
  },
  "flet_text": {
    "prefix": ".flet text",
    "body": [
      "text = ft.Text('$1')",
      "page.add(text)"
    ],
    "description": "Créer un texte Flet"
  },
  "flet_textfield": {
    "prefix": ".flet textfield",
    "body": [
      "textfield = ft.TextField(label='$1')",
      "page.add(textfield)"
    ],
    "description": "Créer un champ de texte Flet"
  },
  "flet_checkbox": {
    "prefix": ".flet checkbox",
    "body": [
      "checkbox = ft.Checkbox(label='$1')",
      "page.add(checkbox)"
    ],
    "description": "Créer une case à cocher Flet"
  },
  "flet_radiobutton": {
    "prefix": ".flet radiobutton",
    "body": [
      "radiobutton = ft.RadioButton(label='$1', value='$2')",
      "page.add(radiobutton)"
    ],
    "description": "Créer un bouton radio Flet"
  },
  "flet_dropdown": {
    "prefix": ".flet dropdown",
    "body": [
      "dropdown = ft.Dropdown(options=[ft.dropdown.Option('$1'), ft.dropdown.Option('$2')])",
      "page.add(dropdown)"
    ],
    "description": "Créer un menu déroulant Flet"
  },
  "flet_slider": {
    "prefix": ".flet slider",
    "body": [
      "slider = ft.Slider(min=$1, max=$2, divisions=$3, label='$4')",
      "page.add(slider)"
    ],
    "description": "Créer un curseur Flet"
  },
  "flet_listview": {
    "prefix": ".flet listview",
    "body": [
      "listview = ft.ListView()",
      "page.add(listview)"
    ],
    "description": "Créer une vue de liste Flet"
  },
  "flet_image": {
    "prefix": ".flet image",
    "body": [
      "image = ft.Image(src='$1')",
      "page.add(image)"
    ],
    "description": "Ajouter une image Flet"
  },
  "flet_row": {
    "prefix": ".flet row",
    "body": [
      "row = ft.Row(controls=[",
      "    ft.Text('$1'),",
      "    ft.ElevatedButton(text='$2', on_click=$3)",
      "])",
      "page.add(row)"
    ],
    "description": "Créer une rangée Flet"
  },
  "flet_column": {
    "prefix": ".flet column",
    "body": [
      "column = ft.Column(controls=[",
      "    ft.Text('$1'),",
      "    ft.ElevatedButton(text='$2', on_click=$3)",
      "])",
      "page.add(column)"
    ],
    "description": "Créer une colonne Flet"
  },
  "flet_container": {
    "prefix": ".flet container",
    "body": [
      "container = ft.Container(",
      "    content=ft.Text('$1'),",
      "    width=$2,",
      "    height=$3,",
      "    bgcolor='$4'",
      ")",
      "page.add(container)"
    ],
    "description": "Créer un conteneur Flet"
  },
  "flet_tabs": {
    "prefix": ".flet tabs",
    "body": [
      "tabs = ft.Tabs(tabs=[",
      "    ft.Tab(text='$1', content=ft.Text('$2')),",
      "    ft.Tab(text='$3', content=ft.Text('$4'))",
      "])",
      "page.add(tabs)"
    ],
    "description": "Créer des onglets Flet"
  },
  "flet_progress_bar": {
    "prefix": ".flet progress bar",
    "body": [
      "progress_bar = ft.ProgressBar(value=$1)",
      "page.add(progress_bar)"
    ],
    "description": "Créer une barre de progression Flet"
  },
  "flet_card": {
    "prefix": ".flet card",
    "body": [
      "card = ft.Card(",
      "    content=ft.Container(",
      "        content=ft.Text('$1'),",
      "        padding=10",
      "    )",
      ")",
      "page.add(card)"
    ],
    "description": "Créer une carte Flet"
  },
  "flet_alert_dialog": {
    "prefix": ".flet alert dialog",
    "body": [
      "dialog = ft.AlertDialog(",
      "    title=ft.Text('$1'),",
      "    content=ft.Text('$2'),",
      "    actions=[ft.TextButton('$3', on_click=$4)]",
      ")",
      "page.dialog = dialog",
      "dialog.open = True",
      "page.update()"
    ],
    "description": "Créer une boîte de dialogue d'alerte Flet"
  },
  "flet_snackbar": {
    "prefix": ".flet snackbar",
    "body": [
      "snackbar = ft.SnackBar(content=ft.Text('$1'))",
      "page.snack_bar = snackbar",
      "snackbar.open = True",
      "page.update()"
    ],
    "description": "Afficher une barre de notification Flet"
  },
  "flet_textbutton": {
    "prefix": ".flet textbutton",
    "body": [
      "textbutton = ft.TextButton(text='$1', on_click=$2)",
      "page.add(textbutton)"
    ],
    "description": "Créer un bouton texte Flet"
  },
  "flet_iconbutton": {
    "prefix": ".flet iconbutton",
    "body": [
      "iconbutton = ft.IconButton(icon=ft.icons.$1, on_click=$2)",
      "page.add(iconbutton)"
    ],
    "description": "Créer un bouton icône Flet"
  },
  "flet_checkbox_group": {
    "prefix": ".flet checkbox group",
    "body": [
      "checkbox_group = ft.CheckboxGroup(options=[",
      "    ft.Checkbox(label='$1'),",
      "    ft.Checkbox(label='$2')",
      "])",
      "page.add(checkbox_group)"
    ],
    "description": "Créer un groupe de cases à cocher Flet"
  },
  "flet_radio_group": {
    "prefix": ".flet radio group",
    "body": [
      "radio_group = ft.RadioGroup(options=[",
      "    ft.Radio(label='$1', value='$2'),",
      "    ft.Radio(label='$3', value='$4')",
      "])",
      "page.add(radio_group)"
    ],
    "description": "Créer un groupe de boutons radio Flet"
  },
  "flet_textfield_password": {
    "prefix": ".flet textfield password",
    "body": [
      "password_field = ft.TextField(label='$1', password=True)",
      "page.add(password_field)"
    ],
    "description": "Créer un champ de texte pour mot de passe Flet"
  },
  "flet_snackbar_action": {
    "prefix": ".flet snackbar action",
    "body": [
      "snackbar = ft.SnackBar(",
      "    content=ft.Text('$1'),",
      "    action=ft.TextButton('$2', on_click=$3)",
      ")",
      "page.snack_bar = snackbar",
      "snackbar.open = True",
      "page.update()"
    ],
    "description": "Afficher une barre de notification avec action Flet"
  },
  "flet_navigation_rail": {
    "prefix": ".flet navigation rail",
    "body": [
      "nav_rail = ft.NavigationRail(",
      "    selected_index=0,",
      "    destinations=[",
      "        ft.NavigationRailDestination(icon=ft.icons.$1, label='$2'),",
      "        ft.NavigationRailDestination(icon=ft.icons.$3, label='$4')",
      "    ]",
      ")",
      "page.add(nav_rail)"
    ],
    "description": "Créer une barre de navigation latérale Flet"
  },
  "flet_responsive_row": {
    "prefix": ".flet responsive row",
    "body": [
      "responsive_row = ft.ResponsiveRow(controls=[",
      "    ft.Text('$1'),",
      "    ft.ElevatedButton(text='$2', on_click=$3)",
      "])",
      "page.add(responsive_row)"
    ],
    "description": "Créer une rangée responsive Flet"
  },
  "flet_progress_ring": {
    "prefix": ".flet progress ring",
    "body": [
      "progress_ring = ft.ProgressRing(value=$1)",
      "page.add(progress_ring)"
    ],
    "description": "Créer un anneau de progression Flet"
  },
  "flet_slider_with_label": {
    "prefix": ".flet slider label",
    "body": [
      "slider = ft.Slider(min=$1, max=$2, divisions=$3, label='$4')",
      "page.add(slider)"
    ],
    "description": "Créer un curseur avec étiquette Flet"
  },
  "flet_textfield_multiline": {
    "prefix": ".flet textfield multiline",
    "body": [
      "textfield = ft.TextField(label='$1', multiline=True, max_lines=$2)",
      "page.add(textfield)"
    ],
    "description": "Créer un champ de texte multiligne Flet"
  },
  "flet_icon": {
    "prefix": ".flet icon",
    "body": [
      "icon = ft.Icon(name=ft.icons.$1, color='$2', size=$3)",
      "page.add(icon)"
    ],
    "description": "Ajouter une icône Flet"
  },
  "flet_divider": {
    "prefix": ".flet divider",
    "body": [
      "divider = ft.Divider(height=$1, thickness=$2, color='$3')",
      "page.add(divider)"
    ],
    "description": "Ajouter un séparateur Flet"
  },
  "flet_switch": {
    "prefix": ".flet switch",
    "body": [
      "switch = ft.Switch(label='$1', value=$2, on_change=$3)",
      "page.add(switch)"
    ],
    "description": "Créer un interrupteur Flet"
  },
  "flet_checkbox_with_value": {
    "prefix": ".flet checkbox value",
    "body": [
      "checkbox = ft.Checkbox(label='$1', value=$2, on_change=$3)",
      "page.add(checkbox)"
    ],
    "description": "Créer une case à cocher avec valeur Flet"
  },
  "flet_slider_with_onchange": {
    "prefix": ".flet slider onchange",
    "body": [
      "slider = ft.Slider(min=$1, max=$2, divisions=$3, label='$4', on_change=$5)",
      "page.add(slider)"
    ],
    "description": "Créer un curseur avec événement de changement Flet"
  },
  "flet_text_with_style": {
    "prefix": ".flet text style",
    "body": [
      "text = ft.Text('$1', size=$2, weight=ft.FontWeight.$3, color='$4')",
      "page.add(text)"
    ],
    "description": "Créer un texte avec style Flet"
  },
  "flet_gridview": {
    "prefix": ".flet gridview",
    "body": [
      "gridview = ft.GridView(expand=True, runs_count=$1, child_aspect_ratio=$2, spacing=$3, controls=[",
      "    ft.Text('$4'),",
      "    ft.ElevatedButton(text='$5', on_click=$6)",
      "])",
      "page.add(gridview)"
    ],
    "description": "Créer une vue en grille Flet"
  },
  "flet_responsive_column": {
    "prefix": ".flet responsive column",
    "body": [
      "responsive_column = ft.ResponsiveColumn(controls=[",
      "    ft.Text('$1'),",
      "    ft.ElevatedButton(text='$2', on_click=$3)",
      "])",
      "page.add(responsive_column)"
    ],
    "description": "Créer une colonne responsive Flet"
  },
  "flet_navigation_bar": {
    "prefix": ".flet navigation bar",
    "body": [
      "nav_bar = ft.NavigationBar(destinations=[",
      "    ft.NavigationDestination(icon=ft.icons.$1, label='$2'),",
      "    ft.NavigationDestination(icon=ft.icons.$3, label='$4')",
      "], on_change=$5)",
      "page.add(nav_bar)"
    ],
    "description": "Créer une barre de navigation Flet"
  },
  "numpy_import": {
    "prefix": ".numpy import",
    "body": [
      "import numpy as np"
    ],
    "description": "Importer la bibliothèque NumPy"
  },
  "numpy_array": {
    "prefix": ".numpy array",
    "body": [
      "np.array([$1])"
    ],
    "description": "Créer un tableau NumPy"
  },
  "numpy_zeros": {
    "prefix": ".numpy zeros",
    "body": [
      "np.zeros(($1, $2))"
    ],
    "description": "Créer un tableau de zéros NumPy"
  },
  "numpy_ones": {
    "prefix": ".numpy ones",
    "body": [
      "np.ones(($1, $2))"
    ],
    "description": "Créer un tableau de uns NumPy"
  },
  "numpy_arange": {
    "prefix": ".numpy arange",
    "body": [
      "np.arange($1, $2, $3)"
    ],
    "description": "Créer un tableau avec une plage de valeurs NumPy"
  },
  "numpy_linspace": {
    "prefix": ".numpy linspace",
    "body": [
      "np.linspace($1, $2, $3)"
    ],
    "description": "Créer un tableau avec des valeurs espacées linéairement NumPy"
  },
  "numpy_reshape": {
    "prefix": ".numpy reshape",
    "body": [
      "np.reshape($1, ($2, $3))"
    ],
    "description": "Redimensionner un tableau NumPy"
  },
  "numpy_transpose": {
    "prefix": ".numpy transpose",
    "body": [
      "np.transpose($1)"
    ],
    "description": "Transposer un tableau NumPy"
  },
  "numpy_dot": {
    "prefix": ".numpy dot",
    "body": [
      "np.dot($1, $2)"
    ],
    "description": "Produit matriciel de deux tableaux NumPy"
  },
  "numpy_sum": {
    "prefix": ".numpy sum",
    "body": [
      "np.sum($1)"
    ],
    "description": "Calculer la somme des éléments d'un tableau NumPy"
  },
  "numpy_mean": {
    "prefix": ".numpy mean",
    "body": [
      "np.mean($1)"
    ],
    "description": "Calculer la moyenne des éléments d'un tableau NumPy"
  },
  "numpy_median": {
    "prefix": ".numpy median",
    "body": [
      "np.median($1)"
    ],
    "description": "Calculer la médiane des éléments d'un tableau NumPy"
  },
  "numpy_std": {
    "prefix": ".numpy std",
    "body": [
      "np.std($1)"
    ],
    "description": "Calculer l'écart type des éléments d'un tableau NumPy"
  },
  "numpy_var": {
    "prefix": ".numpy var",
    "body": [
      "np.var($1)"
    ],
    "description": "Calculer la variance des éléments d'un tableau NumPy"
  },
  "numpy_min": {
    "prefix": ".numpy min",
    "body": [
      "np.min($1)"
    ],
    "description": "Trouver la valeur minimale dans un tableau NumPy"
  },
  "numpy_max": {
    "prefix": ".numpy max",
    "body": [
      "np.max($1)"
    ],
    "description": "Trouver la valeur maximale dans un tableau NumPy"
  },
  "numpy_argmin": {
    "prefix": ".numpy argmin",
    "body": [
      "np.argmin($1)"
    ],
    "description": "Trouver l'indice de la valeur minimale dans un tableau NumPy"
  },
  "numpy_argmax": {
    "prefix": ".numpy argmax",
    "body": [
      "np.argmax($1)"
    ],
    "description": "Trouver l'indice de la valeur maximale dans un tableau NumPy"
  },
  "numpy_unique": {
    "prefix": ".numpy unique",
    "body": [
      "np.unique($1)"
    ],
    "description": "Trouver les éléments uniques dans un tableau NumPy"
  },
  "numpy_sort": {
    "prefix": ".numpy sort",
    "body": [
      "np.sort($1)"
    ],
    "description": "Trier un tableau NumPy"
  },
  "numpy_concatenate": {
    "prefix": ".numpy concatenate",
    "body": [
      "np.concatenate(($1, $2), axis=$3)"
    ],
    "description": "Concaténer deux tableaux NumPy"
  },
  "numpy_stack": {
    "prefix": ".numpy stack",
    "body": [
      "np.stack(($1, $2), axis=$3)"
    ],
    "description": "Empiler des tableaux NumPy le long d'un nouvel axe"
  },
  "flask_setup": {
    "prefix": ".flask setup",
    "body": [
      "from flask import Flask",
      "app = Flask(__name__)",
      "",
      "@app.route('/')",
      "def home():",
      "    return 'Hello, Flask!'",
      "",
      "if __name__ == '__main__':",
      "    app.run(debug=True)"
    ],
    "description": "Initialiser une application Flask"
  },
  "flask_route": {
    "prefix": ".flask route",
    "body": [
      "@app.route('$1')",
      "def $2():",
      "    return '$3'"
    ],
    "description": "Créer une route Flask"
  },
  "flask_render_template": {
    "prefix": ".flask render_template",
    "body": [
      "from flask import render_template",
      "",
      "@app.route('$1')",
      "def $2():",
      "    return render_template('$3')"
    ],
    "description": "Rendre un template avec Flask"
  },
  "flask_request": {
    "prefix": ".flask request",
    "body": [
      "from flask import request",
      "",
      "@app.route('$1', methods=['GET', 'POST'])",
      "def $2():",
      "    if request.method == 'POST':",
      "        $3 = request.form['$3']",
      "        return '$4'",
      "    return '$5'"
    ],
    "description": "Gérer les requêtes GET et POST avec Flask"
  },
  "flask_redirect": {
    "prefix": ".flask redirect",
    "body": [
      "from flask import redirect, url_for",
      "",
      "@app.route('$1')",
      "def $2():",
      "    return redirect(url_for('$3'))"
    ],
    "description": "Rediriger une route avec Flask"
  },
  "recherche_sequentielle": {
    "prefix": ".algo",
    "body": [
      "def recherche_sequentielle(liste, valeur):",
      "    for i in range(len(liste)):",
      "        if liste[i] == valeur:",
      "            return i",
      "    return -1"
    ],
    "description": "Recherche séquentielle d'une valeur dans une liste."
  },
  "recherche_dichotomique": {
    "prefix": ".algo",
    "body": [
      "def recherche_dichotomique(liste, valeur):",
      "    debut, fin = 0, len(liste) - 1",
      "    while debut <= fin:",
      "        milieu = (debut + fin) // 2",
      "        if liste[milieu] == valeur:",
      "            return milieu",
      "        elif liste[milieu] < valeur:",
      "            debut = milieu + 1",
      "        else:",
      "            fin = milieu - 1",
      "    return -1"
    ],
    "description": "Recherche dichotomique d'une valeur dans une liste triée."
  },
  "tri_bulle": {
    "prefix": ".algo",
    "body": [
      "def tri_bulle(liste):",
      "    n = len(liste)",
      "    for i in range(n):",
      "        for j in range(0, n - i - 1):",
      "            if liste[j] > liste[j + 1]:",
      "                liste[j], liste[j + 1] = liste[j + 1], liste[j]"
    ],
    "description": "Tri à bulles pour trier une liste."
  },
  "tri_insertion": {
    "prefix": ".algo",
    "body": [
      "def tri_insertion(liste):",
      "    for i in range(1, len(liste)):",
      "        cle = liste[i]",
      "        j = i - 1",
      "        while j >= 0 and cle < liste[j]:",
      "            liste[j + 1] = liste[j]",
      "            j -= 1",
      "        liste[j + 1] = cle"
    ],
    "description": "Tri par insertion pour trier une liste."
  },
  "tri_selection": {
    "prefix": ".algo",
    "body": [
      "def tri_selection(liste):",
      "    for i in range(len(liste)):",
      "        min_idx = i",
      "        for j in range(i + 1, len(liste)):",
      "            if liste[j] < liste[min_idx]:",
      "                min_idx = j",
      "        liste[i], liste[min_idx] = liste[min_idx], liste[i]"
    ],
    "description": "Tri par sélection pour trier une liste."
  },
  "tri_rapide": {
    "prefix": ".algo",
    "body": [
      "def tri_rapide(liste):",
      "    if len(liste) <= 1:",
      "        return liste",
      "    pivot = liste[len(liste) // 2]",
      "    gauche = [x for x in liste if x < pivot]",
      "    milieu = [x for x in liste if x == pivot]",
      "    droite = [x for x in liste if x > pivot]",
      "    return tri_rapide(gauche) + milieu + tri_rapide(droite)"
    ],
    "description": "Tri rapide pour trier une liste."
  },
  "ri_fusion": {
    "prefix": ".algo",
    "body": [
      "def tri_fusion(liste):",
      "    if len(liste) <= 1:",
      "        return liste",
      "    milieu = len(liste) // 2",
      "    gauche = tri_fusion(liste[:milieu])",
      "    droite = tri_fusion(liste[milieu:])",
      "    return fusionner(gauche, droite)",
      "",
      "def fusionner(gauche, droite):",
      "    resultat = []",
      "    i = j = 0",
      "    while i < len(gauche) and j < len(droite):",
      "        if gauche[i] < droite[j]:",
      "            resultat.append(gauche[i])",
      "            i += 1",
      "        else:",
      "            resultat.append(droite[j])",
      "            j += 1",
      "    resultat.extend(gauche[i:])",
      "    resultat.extend(droite[j:])",
      "    return resultat"
    ],
    "description": "Tri fusion pour trier une liste."
  },
  "pygame_init": {
    "prefix": ".pg setup",
    "body": [
      "import pygame",
      "pygame.init()",
      "screen = pygame.display.set_mode((500, 500))",
      "pygame.display.set_caption('')",
      "clock = pygame.time.Clock()",
      "running = True",
      "while running:",
      "    for event in pygame.event.get():",
      "        if event.type == pygame.QUIT:",
      "            running = False",
      "    screen.fill((0, 0, 0))",
      "    pygame.display.flip()",
      "    clock.tick(60)",
      "pygame.quit()"
    ],
    "description": "Initialiser Pygame et créer une fenêtre"
  },
  "pygame_color": {
    "prefix": ".pg color",
    "body": [
      "color = pygame.Color('$1')"
    ],
    "description": "Créer une couleur Pygame"
  },
  "pygame_display": {
    "prefix": ".pg display",
    "body": [
      "pygame.display.set_caption('$1')",
      "screen = pygame.display.set_mode(($2, $3))",
      "pygame.display.flip()"
    ],
    "description": "Configurer l'affichage Pygame"
  },
  "pygame_draw": {
    "prefix": ".pg draw",
    "body": [
      "pygame.draw.rect(screen, $1, ($2, $3, $4, $5))"
    ],
    "description": "Dessiner un rectangle"
  },
  "pygame_event": {
    "prefix": ".pg event",
    "body": [
      "for event in pygame.event.get():",
      "    if event.type == pygame.QUIT:",
      "        running = False"
    ],
    "description": "Gérer les événements"
  },
  "pygame_font": {
    "prefix": ".pg font",
    "body": [
      "font = pygame.font.SysFont('$1', $2)",
      "text = font.render('$3', True, $4)",
      "screen.blit(text, ($5, $6))"
    ],
    "description": "Afficher du texte avec une police"
  },
  "pygame_image": {
    "prefix": ".pg image",
    "body": [
      "image = pygame.image.load('$1')",
      "screen.blit(image, ($2, $3))"
    ],
    "description": "Charger et afficher une image"
  },
  "pygame_key": {
    "prefix": ".pg key",
    "body": [
      "keys = pygame.key.get_pressed()",
      "if keys[pygame.K_$1]:",
      "    print('$1 pressed')"
    ],
    "description": "Détecter une touche pressée"
  },
  "pygame_locals": {
    "prefix": ".pg locals",
    "body": [
      "from pygame.locals import *"
    ],
    "description": "Importer les constantes locales de Pygame"
  },
  "pygame_mixer": {
    "prefix": ".pg mixer",
    "body": [
      "pygame.mixer.init()",
      "sound = pygame.mixer.Sound('$1.wav')",
      "sound.play()"
    ],
    "description": "Utiliser le module audio"
  },
  "pygame_mouse": {
    "prefix": ".pg mouse",
    "body": [
      "x, y = pygame.mouse.get_pos()",
      "if pygame.mouse.get_pressed()[0]:",
      "    print('Left click at', x, y)"
    ],
    "description": "Gérer la souris"
  },
  "pygame_rect": {
    "prefix": ".pg rect",
    "body": [
      "rect = pygame.Rect($1, $2, $3, $4)"
    ],
    "description": "Créer un rectangle"
  },
  "pygame_surface": {
    "prefix": ".pg surface",
    "body": [
      "surface = pygame.Surface(($1, $2))",
      "surface.fill($3)",
      "screen.blit(surface, ($4, $5))"
    ],
    "description": "Créer et afficher une surface"
  },
  "pygame_time": {
    "prefix": ".pg time",
    "body": [
      "clock = pygame.time.Clock()",
      "clock.tick($1)"
    ],
    "description": "Contrôler le temps"
  },
  "pygame_music": {
    "prefix": ".pg music",
    "body": [
      "pygame.mixer.music.load('$1.mp3')",
      "pygame.mixer.music.play(-1)"
    ],
    "description": "Jouer de la musique en fond"
  },
  "pygame_cursors": {
    "prefix": ".pg cursors",
    "body": [
      "pygame.mouse.set_cursor(*pygame.cursors.arrow)"
    ],
    "description": "Changer le curseur"
  },
  "pygame_joystick": {
    "prefix": ".pg joystick",
    "body": [
      "pygame.joystick.init()",
      "joystick = pygame.joystick.Joystick(0)",
      "joystick.init()"
    ],
    "description": "Initialiser une manette"
  },
  "pygame_mask": {
    "prefix": ".pg mask",
    "body": [
      "mask = pygame.mask.from_surface($1)",
      "overlap = mask.overlap($2, ($3, $4))"
    ],
    "description": "Détection de collision avec masque"
  },
  "pygame_sprite": {
    "prefix": ".pg sprite",
    "body": [
      "class MySprite(pygame.sprite.Sprite):",
      "    def __init__(self):",
      "        super().__init__()",
      "        self.image = pygame.Surface(($1, $2))",
      "        self.rect = self.image.get_rect()"
    ],
    "description": "Créer une classe de sprite"
  },
  "pygame_transform": {
    "prefix": ".pg transform",
    "body": [
      "rotated = pygame.transform.rotate($1, $2)",
      "scaled = pygame.transform.scale($1, ($3, $4))"
    ],
    "description": "Transformer une image"
  },
  "pygame_bufferproxy": {
    "prefix": ".pg bufferproxy",
    "body": [
      "proxy = screen.get_buffer()"
    ],
    "description": "Utiliser BufferProxy"
  },
  "pygame_freetype": {
    "prefix": ".pg freetype",
    "body": [
      "import pygame.freetype",
      "ft_font = pygame.freetype.SysFont('$1', $2)",
      "ft_font.render_to(screen, ($3, $4), '$5', $6)"
    ],
    "description": "Texte avec pygame.freetype"
  },
  "pygame_gfxdraw": {
    "prefix": ".pg gfxdraw",
    "body": [
      "pygame.gfxdraw.aacircle(screen, $1, $2, $3, $4)"
    ],
    "description": "Dessiner avec gfxdraw"
  },
  "pygame_midi": {
    "prefix": ".pg midi",
    "body": [
      "pygame.midi.init()",
      "device = pygame.midi.Output(0)",
      "device.note_on(60, 127)"
    ],
    "description": "Utiliser le MIDI"
  },
  "pygame_pixelarray": {
    "prefix": ".pg pixelarray",
    "body": [
      "px = pygame.PixelArray($1)",
      "px[$2][$3] = $4"
    ],
    "description": "Manipuler les pixels"
  },
  "pygame_pixelcopy": {
    "prefix": ".pg pixelcopy",
    "body": [
      "pygame.pixelcopy.surface_to_array($1, $2)"
    ],
    "description": "Copier des pixels"
  },
  "pygame_sndarray": {
    "prefix": ".pg sndarray",
    "body": [
      "array = pygame.sndarray.array($1)",
      "pygame.sndarray.make_sound(array).play()"
    ],
    "description": "Manipuler les sons comme tableaux"
  },
  "pygame_surfarray": {
    "prefix": ".pg surfarray",
    "body": [
      "array = pygame.surfarray.array3d($1)"
    ],
    "description": "Manipuler les surfaces comme tableaux"
  },
  "pygame_math": {
    "prefix": ".pg math",
    "body": [
      "vec = pygame.math.Vector2($1, $2)",
      "vec.normalize_ip()"
    ],
    "description": "Utiliser Vector2 avec pygame.math"
  },
  "pygame_camera": {
    "prefix": ".pg camera",
    "body": [
      "pygame.camera.init()",
      "cam = pygame.camera.Camera(pygame.camera.list_cameras()[0])",
      "cam.start()",
      "img = cam.get_image()"
    ],
    "description": "Utiliser une caméra"
  },
  "pygame_controller": {
    "prefix": ".pg controller",
    "body": [
      "pygame.joystick.init()",
      "controller = pygame.joystick.Joystick(0)",
      "controller.init()"
    ],
    "description": "Initialiser une manette (controller)"
  },
  "pygame_fastevent": {
    "prefix": ".pg fastevent",
    "body": [
      "pygame.fastevent.init()",
      "for event in pygame.fastevent.get():",
      "    if event.type == pygame.QUIT:",
      "        running = False"
    ],
    "description": "Utiliser fastevent"
  },
  "pygame_scrap": {
    "prefix": ".pg scrap",
    "body": [
      "pygame.scrap.init()",
      "pygame.scrap.put(pygame.SCRAP_TEXT, b'$1')"
    ],
    "description": "Utiliser le presse-papier"
  },
  "pygame_tests": {
    "prefix": ".pg tests",
    "body": [
      "# Aucun test inclus par défaut, utiliser unittest ou pytest"
    ],
    "description": "Tests unitaires avec Pygame (manuel)"
  },
  "pygame_touch": {
    "prefix": ".pg touch",
    "body": [
      "if event.type == pygame.FINGERDOWN:",
      "    print(event.x, event.y)"
    ],
    "description": "Gérer les événements tactiles"
  },
  "mtlib_pyplot": {
    "prefix": ".mtlib Pyplot",
    "body": [
      "import matplotlib.pyplot as plt"
    ],
    "description": "Importer matplotlib.pyplot"
  },
  "mtlib_plotting": {
    "prefix": ".mtlib Plotting",
    "body": [
      "plt.plot($1, $2)",
      "plt.show()"
    ],
    "description": "Tracer un graphique simple"
  },
  "mtlib_markers": {
    "prefix": ".mtlib",
    "body": [
      "plt.plot($1, $2, marker='$3')",
      "plt.show()"
    ],
    "description": "Utiliser des marqueurs dans un graphique"
  },
  "mtlib_line": {
    "prefix": ".mtlib Line",
    "body": [
      "plt.plot($1, $2, linestyle='$3')",
      "plt.show()"
    ],
    "description": "Changer le style de ligne"
  },
  "mtlib_labels": {
    "prefix": ".mtlib Labels",
    "body": [
      "plt.xlabel('$1')",
      "plt.ylabel('$2')",
      "plt.title('$3')"
    ],
    "description": "Ajouter des étiquettes et un titre"
  },
  "mtlib_grid": {
    "prefix": ".mtlib Grid",
    "body": [
      "plt.grid(True)"
    ],
    "description": "Afficher la grille"
  },
  "mtlib_subplot": {
    "prefix": ".mtlib Subplot",
    "body": [
      "plt.subplot($1, $2, $3)",
      "plt.plot($4, $5)",
      "plt.title('$6')"
    ],
    "description": "Créer un subplot"
  },
  "mtlib_scatter": {
    "prefix": ".mtlib Scatter",
    "body": [
      "plt.scatter($1, $2)",
      "plt.show()"
    ],
    "description": "Créer un graphique de dispersion"
  },
  "mtlib_bars": {
    "prefix": ".mtlib Bars",
    "body": [
      "plt.bar($1, $2)",
      "plt.show()"
    ],
    "description": "Créer un graphique à barres"
  },
  "mtlib_histograms": {
    "prefix": ".mtlib Histograms",
    "body": [
      "plt.hist($1, bins=$2)",
      "plt.show()"
    ],
    "description": "Créer un histogramme"
  },
  "mtlib_piecharts": {
    "prefix": ".mtlib Pie Charts",
    "body": [
      "plt.pie($1, labels=$2, autopct='%1.1f%%')",
      "plt.show()"
    ],
    "description": "Créer un graphique en secteurs (camembert)"
  },
  "files_read": {
    "prefix": ".files read",
    "body": [
      "with open('$1', 'r') as file:",
      "    content = file.read()",
      "    print(content)"
    ],
    "description": "Lire un fichier"
  },
  "files_write": {
    "prefix": ".files write",
    "body": [
      "with open('$1', 'w') as file:",
      "    file.write('$2')"
    ],
    "description": "Écrire dans un fichier (écrase le contenu existant)"
  },
  "files_append": {
    "prefix": ".files append",
    "body": [
      "with open('$1', 'a') as file:",
      "    file.write('$2')"
    ],
    "description": "Ajouter à un fichier (sans effacer l'ancien contenu)"
  },
  "files_create": {
    "prefix": ".files create",
    "body": [
      "with open('$1', 'x') as file:",
      "    file.write('$2')"
    ],
    "description": "Créer un fichier (échoue si le fichier existe déjà)"
  },
  "files_delete": {
    "prefix": ".files delete",
    "body": [
      "import os",
      "if os.path.exists('$1'):",
      "    os.remove('$1')",
      "else:",
      "    print(\"Le fichier n'existe pas\")"
    ],
    "description": "Supprimer un fichier"
  },
  "files_modes_doc": {
    "prefix": ".files modes",
    "body": [
      "# Modes d'ouverture de fichier :",
      "# 'r' : lecture (par défaut)",
      "# 'w' : écriture (écrase)",
      "# 'x' : création (échoue si existe)",
      "# 'a' : ajout",
      "# 'b' : binaire",
      "# 't' : texte (par défaut)",
      "# '+' : lecture et écriture"
    ],
    "description": "Documentation rapide sur les modes d'ouverture"
  },
  "django_views": {
    "prefix": ".Django Views",
    "body": [
      "from django.shortcuts import render",
      "",
      "def $1(request):",
      "    return render(request, '$2.html', {'$3': $4})"
    ],
    "description": "Créer une vue Django"
  },
  "django_templates": {
    "prefix": ".Django Templates",
    "body": [
      "{% extends '$1/base.html' %}",
      "{% block content %}",
      "<h1>$2</h1>",
      "{% endblock %}"
    ],
    "description": "Structure d'un template Django"
  },
  "django_models": {
    "prefix": ".Django Models",
    "body": [
      "from django.db import models",
      "",
      "class $1(models.Model):",
      "    $2 = models.$3Field($4)",
      "",
      "    def __str__(self):",
      "        return self.$2"
    ],
    "description": "Créer un modèle Django"
  },
  "django_add_members": {
    "prefix": ".Django Add Members",
    "body": [
      "from .models import $1",
      "$1.objects.create($2='$3', $4='$5')"
    ],
    "description": "Ajouter un enregistrement à un modèle"
  },
  "django_add_template": {
    "prefix": ".Django Add Template",
    "body": [
      "from django.shortcuts import render",
      "",
      "def $1(request):",
      "    return render(request, '$2.html')"
    ],
    "description": "Rendre un template depuis une vue"
  },
  "django_add_record": {
    "prefix": ".Django Add Record",
    "body": [
      "instance = $1($2='$3', $4='$5')",
      "instance.save()"
    ],
    "description": "Créer et sauvegarder un nouvel enregistrement"
  },
  "django_delete_record": {
    "prefix": ".Django Delete Record",
    "body": [
      "$1.objects.filter($2='$3').delete()"
    ],
    "description": "Supprimer un enregistrement"
  },
  "django_update_record": {
    "prefix": ".Django Update Record",
    "body": [
      "record = $1.objects.get($2='$3')",
      "record.$4 = '$5'",
      "record.save()"
    ],
    "description": "Mettre à jour un enregistrement"
  },
  "django_variables": {
    "prefix": ".Django Variables",
    "body": [
      "{{ $1 }}"
    ],
    "description": "Afficher une variable dans un template"
  },
  "django_tags": {
    "prefix": ".Django Tags",
    "body": [
      "{% $1 %}"
    ],
    "description": "Balise Django générique"
  },
  "django_if_else": {
    "prefix": ".Django If Else",
    "body": [
      "{% if $1 %}",
      "  $2",
      "{% else %}",
      "  $3",
      "{% endif %}"
    ],
    "description": "Condition if/else dans un template"
  },
  "django_for_loop": {
    "prefix": ".Django For Loop",
    "body": [
      "{% for $1 in $2 %}",
      "  $3",
      "{% endfor %}"
    ],
    "description": "Boucle for dans un template"
  },
  "django_comment": {
    "prefix": ".Django Comment",
    "body": [
      "{# $1 #}"
    ],
    "description": "Commentaire Django dans un template"
  },
  "django_cycle": {
    "prefix": ".Django Cycle",
    "body": [
      "{% cycle '$1' '$2' %}"
    ],
    "description": "Cycle entre deux valeurs"
  },
  "django_extends": {
    "prefix": ".Django Extends",
    "body": [
      "{% extends '$1/base.html' %}"
    ],
    "description": "Hériter d’un template parent"
  },
  "django_include": {
    "prefix": ".Django Include",
    "body": [
      "{% include '$1.html' %}"
    ],
    "description": "Inclure un autre template"
  },
  "django_filter": {
    "prefix": ".Django Filter",
    "body": [
      "{{ $1|$2 }}"
    ],
    "description": "Utiliser un filtre Django"
  },
  "django_404_template": {
    "prefix": ".Django 404 Template",
    "body": [
      "from django.http import Http404",
      "",
      "def $1(request):",
      "    raise Http404(\"$2\")"
    ],
    "description": "Lever une erreur 404"
  },
  "django_add_static": {
    "prefix": ".Django Add Static Files",
    "body": [
      "{% load static %}"
    ],
    "description": "Charger les fichiers statiques"
  },
  "django_add_css": {
    "prefix": ".Django Add CSS File",
    "body": [
      "<link rel=\"stylesheet\" href=\"{% static '$1.css' %}\">"
    ],
    "description": "Ajouter un fichier CSS"
  },
  "django_add_js": {
    "prefix": ".Django Add JS File",
    "body": [
      "<script src=\"{% static '$1.js' %}\"></script>"
    ],
    "description": "Ajouter un fichier JS"
  },
  "django_add_image": {
    "prefix": ".Django Add Image",
    "body": [
      "<img src=\"{% static '$1.jpg' %}\" alt=\"$2\">"
    ],
    "description": "Ajouter une image statique"
  },
  "django_queryset_get": {
    "prefix": ".Django QuerySet Get",
    "body": [
      "$1.objects.get($2='$3')"
    ],
    "description": "Récupérer un seul objet avec get()"
  },
  "django_queryset_filter": {
    "prefix": ".Django QuerySet Filter",
    "body": [
      "$1.objects.filter($2='$3')"
    ],
    "description": "Filtrer des objets avec filter()"
  },
  "django_queryset_order": {
    "prefix": ".Django QuerySet Order By",
    "body": [
      "$1.objects.all().order_by('$2')"
    ],
    "description": "Trier des objets avec order_by()"
  },
  "ml_mean_median_mode": {
    "prefix": ".ML Mean Median Mode",
    "body": [
      "import statistics",
      "",
      "data = $1",
      "mean = statistics.mean(data)",
      "median = statistics.median(data)",
      "mode = statistics.mode(data)"
    ],
    "description": "Calculer la moyenne, la médiane et le mode"
  },
  "ml_standard_deviation": {
    "prefix": ".ML Standard Deviation",
    "body": [
      "import statistics",
      "",
      "data = $1",
      "stdev = statistics.stdev(data)"
    ],
    "description": "Calcul de l'écart-type"
  },
  "ml_percentile": {
    "prefix": ".ML Percentile",
    "body": [
      "import numpy as np",
      "",
      "data = $1",
      "percentile_90 = np.percentile(data, 90)"
    ],
    "description": "Calcul du percentile"
  },
  "ml_data_distribution": {
    "prefix": ".ML Data Distribution",
    "body": [
      "import matplotlib.pyplot as plt",
      "",
      "plt.hist($1, bins=10)",
      "plt.title('Distribution des données')",
      "plt.show()"
    ],
    "description": "Afficher la distribution des données"
  },
  "ml_normal_distribution": {
    "prefix": ".ML Normal Data Distribution",
    "body": [
      "import numpy as np",
      "import matplotlib.pyplot as plt",
      "",
      "data = np.random.normal(loc=$1, scale=$2, size=1000)",
      "plt.hist(data, bins=30)",
      "plt.show()"
    ],
    "description": "Distribution normale"
  },
  "ml_scatter_plot": {
    "prefix": ".ML Scatter Plot",
    "body": [
      "import matplotlib.pyplot as plt",
      "",
      "plt.scatter($1, $2)",
      "plt.xlabel('$3')",
      "plt.ylabel('$4')",
      "plt.title('Nuage de points')",
      "plt.show()"
    ],
    "description": "Tracer un nuage de points"
  },
  "ml_linear_regression": {
    "prefix": ".ML Linear Regression",
    "body": [
      "from sklearn.linear_model import LinearRegression",
      "",
      "model = LinearRegression()",
      "model.fit($1, $2)",
      "predictions = model.predict($3)"
    ],
    "description": "Régression linéaire"
  },
  "ml_polynomial_regression": {
    "prefix": ".ML Polynomial Regression",
    "body": [
      "from sklearn.preprocessing import PolynomialFeatures",
      "from sklearn.linear_model import LinearRegression",
      "from sklearn.pipeline import make_pipeline",
      "",
      "model = make_pipeline(PolynomialFeatures(degree=$1), LinearRegression())",
      "model.fit($2, $3)",
      "predictions = model.predict($4)"
    ],
    "description": "Régression polynomiale"
  },
  "ml_multiple_regression": {
    "prefix": ".ML Multiple Regression",
    "body": [
      "from sklearn.linear_model import LinearRegression",
      "",
      "model = LinearRegression()",
      "model.fit($1, $2)",
      "predictions = model.predict($3)"
    ],
    "description": "Régression multiple"
  },
  "ml_scale": {
    "prefix": ".ML Scale",
    "body": [
      "from sklearn.preprocessing import StandardScaler",
      "",
      "scaler = StandardScaler()",
      "$1_scaled = scaler.fit_transform($1)"
    ],
    "description": "Mise à l’échelle des données"
  },
  "ml_train_test": {
    "prefix": ".ML Train/Test",
    "body": [
      "from sklearn.model_selection import train_test_split",
      "",
      "X_train, X_test, y_train, y_test = train_test_split($1, $2, test_size=0.2, random_state=42)"
    ],
    "description": "Séparer les données en train/test"
  },
  "ml_decision_tree": {
    "prefix": ".ML Decision Tree",
    "body": [
      "from sklearn.tree import DecisionTreeClassifier",
      "",
      "model = DecisionTreeClassifier()",
      "model.fit($1, $2)",
      "predictions = model.predict($3)"
    ],
    "description": "Arbre de décision"
  },
  "ml_confusion_matrix": {
    "prefix": ".ML Confusion Matrix",
    "body": [
      "from sklearn.metrics import confusion_matrix",
      "",
      "conf_matrix = confusion_matrix($1, $2)"
    ],
    "description": "Matrice de confusion"
  },
  "ml_hierarchical_clustering": {
    "prefix": ".ML Hierarchical Clustering",
    "body": [
      "import scipy.cluster.hierarchy as sch",
      "import matplotlib.pyplot as plt",
      "",
      "dendrogram = sch.dendrogram(sch.linkage($1, method='ward'))",
      "plt.show()"
    ],
    "description": "Clustering hiérarchique"
  },
  "ml_logistic_regression": {
    "prefix": ".ML Logistic Regression",
    "body": [
      "from sklearn.linear_model import LogisticRegression",
      "",
      "model = LogisticRegression()",
      "model.fit($1, $2)",
      "predictions = model.predict($3)"
    ],
    "description": "Régression logistique"
  },
  "ml_grid_search": {
    "prefix": ".ML Grid Search",
    "body": [
      "from sklearn.model_selection import GridSearchCV",
      "",
      "param_grid = $1",
      "grid = GridSearchCV(estimator=$2, param_grid=param_grid, cv=5)",
      "grid.fit($3, $4)"
    ],
    "description": "Recherche de grille pour hyperparamètres"
  },
  "ml_categorical_data": {
    "prefix": ".ML Categorical Data",
    "body": [
      "import pandas as pd",
      "",
      "df['$1'] = pd.factorize(df['$1'])[0]"
    ],
    "description": "Encodage des données catégoriques"
  },
  "ml_kmeans": {
    "prefix": ".ML K-means",
    "body": [
      "from sklearn.cluster import KMeans",
      "",
      "model = KMeans(n_clusters=$1)",
      "model.fit($2)"
    ],
    "description": "Clustering K-means"
  },
  "ml_bootstrap_agg": {
    "prefix": ".ML Bootstrap Aggregation",
    "body": [
      "from sklearn.ensemble import BaggingClassifier",
      "",
      "model = BaggingClassifier(base_estimator=$1, n_estimators=10)",
      "model.fit($2, $3)"
    ],
    "description": "Bootstrap Aggregation (Bagging)"
  },
  "ml_cross_validation": {
    "prefix": ".ML Cross Validation",
    "body": [
      "from sklearn.model_selection import cross_val_score",
      "",
      "scores = cross_val_score($1, $2, $3, cv=5)"
    ],
    "description": "Validation croisée"
  },
  "ml_auc_roc": {
    "prefix": ".ML AUC - ROC Curve",
    "body": [
      "from sklearn.metrics import roc_auc_score, roc_curve",
      "",
      "fpr, tpr, thresholds = roc_curve($1, $2)",
      "auc = roc_auc_score($1, $2)"
    ],
    "description": "Courbe AUC - ROC"
  },
  "ml_knn": {
    "prefix": ".ML K-nearest neighbors",
    "body": [
      "from sklearn.neighbors import KNeighborsClassifier",
      "",
      "model = KNeighborsClassifier(n_neighbors=$1)",
      "model.fit($2, $3)",
      "predictions = model.predict($4)"
    ],
    "description": "K plus proches voisins"
  },
  "pds_import": {
    "prefix": ".pds import",
    "body": [
      "import pandas as pd"
    ],
    "description": "Importer la bibliothèque pandas"
  },
  "pds_read_csv": {
    "prefix": ".pds read csv",
    "body": [
      "df = pd.read_csv('$1.csv')"
    ],
    "description": "Lire un fichier CSV"
  },
  "pds_read_excel": {
    "prefix": ".pds read excel",
    "body": [
      "df = pd.read_excel('$1.xlsx')"
    ],
    "description": "Lire un fichier Excel"
  },
  "pds_head": {
    "prefix": ".pds head",
    "body": [
      "df.head($1)"
    ],
    "description": "Afficher les premières lignes"
  },
  "pds_tail": {
    "prefix": ".pds tail",
    "body": [
      "df.tail($1)"
    ],
    "description": "Afficher les dernières lignes"
  },
  "pds_info": {
    "prefix": ".pds info",
    "body": [
      "df.info()"
    ],
    "description": "Afficher les informations du DataFrame"
  },
  "pds_describe": {
    "prefix": ".pds describe",
    "body": [
      "df.describe()"
    ],
    "description": "Statistiques descriptives"
  },
  "pds_shape": {
    "prefix": ".pds shape",
    "body": [
      "df.shape"
    ],
    "description": "Afficher les dimensions du DataFrame"
  },
  "pds_columns": {
    "prefix": ".pds columns",
    "body": [
      "df.columns"
    ],
    "description": "Afficher les colonnes"
  },
  "pds_select_column": {
    "prefix": ".pds select column",
    "body": [
      "df['$1']"
    ],
    "description": "Sélectionner une colonne"
  },
  "pds_select_multiple_columns": {
    "prefix": ".pds select columns",
    "body": [
      "df[['$1', '$2']]"
    ],
    "description": "Sélectionner plusieurs colonnes"
  },
  "pds_filter_rows": {
    "prefix": ".pds filter rows",
    "body": [
      "df[df['$1'] == '$2']"
    ],
    "description": "Filtrer les lignes selon une condition"
  },
  "pds_sort_values": {
    "prefix": ".pds sort",
    "body": [
      "df.sort_values(by='$1', ascending=$2)"
    ],
    "description": "Trier les valeurs"
  },
  "pds_groupby": {
    "prefix": ".pds groupby",
    "body": [
      "df.groupby('$1')['$2'].$3()"
    ],
    "description": "Grouper par et appliquer une fonction"
  },
  "pds_drop_column": {
    "prefix": ".pds drop column",
    "body": [
      "df.drop('$1', axis=1, inplace=True)"
    ],
    "description": "Supprimer une colonne"
  },
  "pds_dropna": {
    "prefix": ".pds dropna",
    "body": [
      "df.dropna(inplace=True)"
    ],
    "description": "Supprimer les valeurs manquantes"
  },
  "pds_fillna": {
    "prefix": ".pds fillna",
    "body": [
      "df.fillna($1, inplace=True)"
    ],
    "description": "Remplir les valeurs manquantes"
  },
  "pds_to_csv": {
    "prefix": ".pds to csv",
    "body": [
      "df.to_csv('$1.csv', index=False)"
    ],
    "description": "Exporter le DataFrame au format CSV"
  },
  "cv_import": {
    "prefix": ".cv import",
    "body": [
      "import cv2"
    ],
    "description": "Importer OpenCV"
  },
  "cv_read_image": {
    "prefix": ".cv read",
    "body": [
      "img = cv2.imread('$1')"
    ],
    "description": "Lire une image"
  },
  "cv_show_image": {
    "prefix": ".cv show",
    "body": [
      "cv2.imshow('$1', img)",
      "cv2.waitKey(0)",
      "cv2.destroyAllWindows()"
    ],
    "description": "Afficher une image"
  },
  "cv_write_image": {
    "prefix": ".cv write",
    "body": [
      "cv2.imwrite('$1', img)"
    ],
    "description": "Enregistrer une image"
  },
  "cv_resize": {
    "prefix": ".cv resize",
    "body": [
      "resized = cv2.resize(img, ($1, $2))"
    ],
    "description": "Redimensionner une image"
  },
  "cv_gray": {
    "prefix": ".cv gray",
    "body": [
      "gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)"
    ],
    "description": "Convertir une image en niveaux de gris"
  },
  "cv_blur": {
    "prefix": ".cv blur",
    "body": [
      "blurred = cv2.GaussianBlur(img, ($1, $2), 0)"
    ],
    "description": "Appliquer un flou gaussien"
  },
  "cv_canny": {
    "prefix": ".cv canny",
    "body": [
      "edges = cv2.Canny(img, $1, $2)"
    ],
    "description": "Détection de contours (Canny)"
  },
  "cv_draw_rectangle": {
    "prefix": ".cv rect",
    "body": [
      "cv2.rectangle(img, ($1, $2), ($3, $4), ($5, $6, $7), $8)"
    ],
    "description": "Dessiner un rectangle"
  },
  "cv_draw_circle": {
    "prefix": ".cv circle",
    "body": [
      "cv2.circle(img, ($1, $2), $3, ($4, $5, $6), $7)"
    ],
    "description": "Dessiner un cercle"
  },
  "cv_draw_text": {
    "prefix": ".cv text",
    "body": [
      "cv2.putText(img, '$1', ($2, $3), cv2.FONT_HERSHEY_SIMPLEX, $4, ($5, $6, $7), $8)"
    ],
    "description": "Afficher du texte sur une image"
  },
  "cv_video_capture": {
    "prefix": ".cv video",
    "body": [
      "cap = cv2.VideoCapture(0)",
      "while True:",
      "    ret, frame = cap.read()",
      "    if not ret:",
      "        break",
      "    cv2.imshow('Video', frame)",
      "    if cv2.waitKey(1) & 0xFF == ord('q'):",
      "        break",
      "cap.release()",
      "cv2.destroyAllWindows()"
    ],
    "description": "Capture vidéo avec webcam"
  },
  "tsf_import": {
    "prefix": ".tsf import",
    "body": [
      "import tensorflow as tf"
    ],
    "description": "Importer TensorFlow"
  },
  "tsf_constant": {
    "prefix": ".tsf constant",
    "body": [
      "const = tf.constant([$1])"
    ],
    "description": "Créer une constante TensorFlow"
  },
  "tsf_variable": {
    "prefix": ".tsf variable",
    "body": [
      "var = tf.Variable([$1])"
    ],
    "description": "Créer une variable TensorFlow"
  },
  "tsf_placeholder": {
    "prefix": ".tsf placeholder",
    "body": [
      "# tf.placeholder is only for TF1.x",
      "x = tf.compat.v1.placeholder(tf.float32, shape=[$1])"
    ],
    "description": "Créer un placeholder (TF1.x)"
  },
  "tsf_model_sequential": {
    "prefix": ".tsf model seq",
    "body": [
      "model = tf.keras.Sequential([",
      "    tf.keras.layers.Dense($1, activation='$2'),",
      "    tf.keras.layers.Dense($3)",
      "])"
    ],
    "description": "Créer un modèle séquentiel simple"
  },
  "tsf_compile_model": {
    "prefix": ".tsf compile",
    "body": [
      "model.compile(optimizer='$1',",
      "              loss='$2',",
      "              metrics=['$3'])"
    ],
    "description": "Compiler un modèle"
  },
  "tsf_fit_model": {
    "prefix": ".tsf fit",
    "body": [
      "model.fit(x_train, y_train, epochs=$1, batch_size=$2)"
    ],
    "description": "Entraîner le modèle"
  },
  "tsf_evaluate": {
    "prefix": ".tsf eval",
    "body": [
      "loss, accuracy = model.evaluate(x_test, y_test)"
    ],
    "description": "Évaluer le modèle"
  },
  "tsf_predict": {
    "prefix": ".tsf predict",
    "body": [
      "predictions = model.predict($1)"
    ],
    "description": "Faire des prédictions"
  },
  "tsf_tensorboard": {
    "prefix": ".tsf tensorboard",
    "body": [
      "tensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir='$1')"
    ],
    "description": "Créer un callback TensorBoard"
  },
  "tsf_save_model": {
    "prefix": ".tsf save",
    "body": [
      "model.save('$1_model.h5')"
    ],
    "description": "Sauvegarder le modèle"
  },
  "tsf_load_model": {
    "prefix": ".tsf load",
    "body": [
      "model = tf.keras.models.load_model('$1_model.h5')"
    ],
    "description": "Charger un modèle"
  },
  "tsf_dataset_from_tensor": {
    "prefix": ".tsf dataset",
    "body": [
      "dataset = tf.data.Dataset.from_tensor_slices(($1, $2))"
    ],
    "description": "Créer un dataset depuis des tensors"
  },
  "tsf_reshape": {
    "prefix": ".tsf reshape",
    "body": [
      "reshaped = tf.reshape($1, [$2])"
    ],
    "description": "Redimensionner un tenseur"
  },
  "nltk_import": {
    "prefix": ".nltk import",
    "body": [
      "import nltk"
    ],
    "description": "Importer NLTK"
  },
  "nltk_download": {
    "prefix": ".nltk download",
    "body": [
      "nltk.download('$1')"
    ],
    "description": "Télécharger un dataset ou modèle NLTK"
  },
  "nltk_tokenize": {
    "prefix": ".nltk tokenize",
    "body": [
      "from nltk.tokenize import word_tokenize",
      "tokens = word_tokenize('$1')"
    ],
    "description": "Tokenisation des mots"
  },
  "nltk_sent_tokenize": {
    "prefix": ".nltk sent tokenize",
    "body": [
      "from nltk.tokenize import sent_tokenize",
      "sentences = sent_tokenize('$1')"
    ],
    "description": "Tokenisation des phrases"
  },
  "nltk_stopwords": {
    "prefix": ".nltk stopwords",
    "body": [
      "from nltk.corpus import stopwords",
      "stop_words = set(stopwords.words('english'))",
      "filtered = [w for w in tokens if not w.lower() in stop_words]"
    ],
    "description": "Supprimer les mots vides"
  },
  "nltk_pos_tag": {
    "prefix": ".nltk pos tag",
    "body": [
      "from nltk import pos_tag",
      "tags = pos_tag(tokens)"
    ],
    "description": "Étiquetage grammatical"
  },
  "nltk_stemmer": {
    "prefix": ".nltk stem",
    "body": [
      "from nltk.stem import PorterStemmer",
      "stemmer = PorterStemmer()",
      "stemmed = [stemmer.stem(word) for word in tokens]"
    ],
    "description": "Racines des mots (Stemming)"
  },
  "nltk_lemmatizer": {
    "prefix": ".nltk lemmatize",
    "body": [
      "from nltk.stem import WordNetLemmatizer",
      "lemmatizer = WordNetLemmatizer()",
      "lemmatized = [lemmatizer.lemmatize(word) for word in tokens]"
    ],
    "description": "Lemmatisation"
  },
  "nltk_freq_dist": {
    "prefix": ".nltk freqdist",
    "body": [
      "from nltk.probability import FreqDist",
      "freq = FreqDist(tokens)",
      "freq.plot($1)"
    ],
    "description": "Distribution de fréquence"
  },
  "nltk_ngrams": {
    "prefix": ".nltk ngrams",
    "body": [
      "from nltk.util import ngrams",
      "bigrams = list(ngrams(tokens, 2))"
    ],
    "description": "Extraire des n-grams"
  },
  "nltk_named_entity": {
    "prefix": ".nltk ner",
    "body": [
      "from nltk import ne_chunk",
      "from nltk.tree import Tree",
      "chunked = ne_chunk(pos_tag(tokens))"
    ],
    "description": "Reconnaissance d'entités nommées"
  },
  "nltk_word_tokenize": {
    "prefix": ".nltk word tokenize",
    "body": [
      "from nltk.tokenize import word_tokenize",
      "text = \"$1\"",
      "tokens = word_tokenize(text)"
    ],
    "description": "Tokenisation des mots"
  },
  "nltk_sentence_tokenize": {
    "prefix": ".nltk sentence tokenize",
    "body": [
      "from nltk.tokenize import sent_tokenize",
      "text = \"$1\"",
      "sentences = sent_tokenize(text)"
    ],
    "description": "Tokenisation des phrases"
  },
  "nltk_stopword_filtering": {
    "prefix": ".nltk stopword filter",
    "body": [
      "from nltk.corpus import stopwords",
      "stop_words = set(stopwords.words('english'))",
      "filtered = [word for word in tokens if word.lower() not in stop_words]"
    ],
    "description": "Filtrer les mots vides"
  },
  "nltk_punkt_download": {
    "prefix": ".nltk punkt",
    "body": [
      "import nltk",
      "nltk.download('punkt')"
    ],
    "description": "Télécharger le tokenizer Punkt"
  },
  "nltk_pos_tagging": {
    "prefix": ".nltk pos",
    "body": [
      "from nltk import pos_tag",
      "pos_tags = pos_tag(tokens)"
    ],
    "description": "Étiquetage grammatical (POS tagging)"
  },
  "nltk_wordnet_download": {
    "prefix": ".nltk wordnet",
    "body": [
      "import nltk",
      "nltk.download('wordnet')"
    ],
    "description": "Télécharger WordNet"
  },
  "nltk_lemmatizer_wordnet": {
    "prefix": ".nltk lemmatizer",
    "body": [
      "from nltk.stem import WordNetLemmatizer",
      "lemmatizer = WordNetLemmatizer()",
      "lemmatized_words = [lemmatizer.lemmatize(word) for word in tokens]"
    ],
    "description": "Lemmatisation avec WordNet"
  },
  "nltk_porter_stemmer": {
    "prefix": ".nltk porter stemmer",
    "body": [
      "from nltk.stem import PorterStemmer",
      "stemmer = PorterStemmer()",
      "stemmed_words = [stemmer.stem(word) for word in tokens]"
    ],
    "description": "Racines des mots avec Porter"
  },
  "nltk_snowball_stemmer": {
    "prefix": ".nltk snowball stemmer",
    "body": [
      "from nltk.stem import SnowballStemmer",
      "stemmer = SnowballStemmer('english')",
      "stemmed = [stemmer.stem(word) for word in tokens]"
    ],
    "description": "Stemming avec Snowball"
  },
  "nltk_freq_dist_plot": {
    "prefix": ".nltk freq plot",
    "body": [
      "from nltk.probability import FreqDist",
      "fdist = FreqDist(tokens)",
      "fdist.plot($1)"
    ],
    "description": "Tracer la distribution de fréquence"
  },
  "nltk_bigram_trigram": {
    "prefix": ".nltk ngram",
    "body": [
      "from nltk.util import ngrams",
      "bigrams = list(ngrams(tokens, 2))",
      "trigrams = list(ngrams(tokens, 3))"
    ],
    "description": "Extraire les bigrams et trigrams"
  },
  "nltk_chunking": {
    "prefix": ".nltk chunk",
    "body": [
      "from nltk.chunk import RegexpParser",
      "grammar = 'NP: {<DT>?<JJ>*<NN>}'",
      "parser = RegexpParser(grammar)",
      "tree = parser.parse(pos_tag(tokens))"
    ],
    "description": "Chunking avec une expression régulière"
  },
  "nltk_ner": {
    "prefix": ".nltk named entity",
    "body": [
      "from nltk import ne_chunk",
      "ner_tree = ne_chunk(pos_tag(tokens))"
    ],
    "description": "Reconnaissance des entités nommées"
  },
  "nltk_corpus_brown": {
    "prefix": ".nltk brown corpus",
    "body": [
      "from nltk.corpus import brown",
      "print(brown.categories())",
      "print(brown.words(categories='news'))"
    ],
    "description": "Utiliser le corpus Brown"
  },
  "nltk_text_classification": {
    "prefix": ".nltk classifier",
    "body": [
      "from nltk.classify import NaiveBayesClassifier",
      "train_set = [({$1}, 'label1'), ({$2}, 'label2')]",
      "classifier = NaiveBayesClassifier.train(train_set)",
      "classifier.show_most_informative_features()"
    ],
    "description": "Classifier Bayesien naïf"
  },
  "nltk_save_classifier": {
    "prefix": ".nltk save classifier",
    "body": [
      "import pickle",
      "with open('classifier.pkl', 'wb') as f:",
      "    pickle.dump(classifier, f)"
    ],
    "description": "Sauvegarder un classifieur"
  },
  "nltk_load_classifier": {
    "prefix": ".nltk load classifier",
    "body": [
      "import pickle",
      "with open('classifier.pkl', 'rb') as f:",
      "    classifier = pickle.load(f)"
    ],
    "description": "Charger un classifieur"
  },
  "DSA_Bubble_Sort": {
    "prefix": ".dsa bubble sort",
    "body": [
      "def bubble_sort(arr):",
      "    n = len(arr)",
      "    for i in range(n):",
      "        for j in range(0, n-i-1):",
      "            if arr[j] > arr[j+1]:",
      "                arr[j], arr[j+1] = arr[j+1], arr[j]",
      "    return arr"
    ],
    "description": "Tri à bulles pour trier une liste."
  },
  "DSA_Selection_Sort": {
    "prefix": ".dsa selection sort",
    "body": [
      "def selection_sort(arr):",
      "    for i in range(len(arr)):",
      "        min_idx = i",
      "        for j in range(i+1, len(arr)):",
      "            if arr[j] < arr[min_idx]:",
      "                min_idx = j",
      "        arr[i], arr[min_idx] = arr[min_idx], arr[i]",
      "    return arr"
    ],
    "description": "Tri par sélection pour trier une liste."
  },
  "DSA_Insertion_Sort": {
    "prefix": ".dsa insertion sort",
    "body": [
      "def insertion_sort(arr):",
      "    for i in range(1, len(arr)):",
      "        key = arr[i]",
      "        j = i - 1",
      "        while j >= 0 and key < arr[j]:",
      "            arr[j + 1] = arr[j]",
      "            j -= 1",
      "        arr[j + 1] = key",
      "    return arr"
    ],
    "description": "Tri par insertion pour trier une liste."
  },
  "DSA_Quick_Sort": {
    "prefix": ".dsa quick sort",
    "body": [
      "def quick_sort(arr):",
      "    if len(arr) <= 1:",
      "        return arr",
      "    pivot = arr[len(arr) // 2]",
      "    left = [x for x in arr if x < pivot]",
      "    middle = [x for x in arr if x == pivot]",
      "    right = [x for x in arr if x > pivot]",
      "    return quick_sort(left) + middle + quick_sort(right)"
    ],
    "description": "Tri rapide pour trier une liste."
  },
  "DSA_Counting_Sort": {
    "prefix": ".dsa counting sort",
    "body": [
      "def counting_sort(arr):",
      "    max_val = max(arr)",
      "    count = [0] * (max_val + 1)",
      "    for num in arr:",
      "        count[num] += 1",
      "    sorted_arr = []",
      "    for i, c in enumerate(count):",
      "        sorted_arr.extend([i] * c)",
      "    return sorted_arr"
    ],
    "description": "Tri par comptage pour trier une liste."
  },
  "DSA_Radix_Sort": {
    "prefix": ".dsa radix sort",
    "body": [
      "def counting_sort_for_radix(arr, exp):",
      "    n = len(arr)",
      "    output = [0] * n",
      "    count = [0] * 10",
      "    for i in range(n):",
      "        index = (arr[i] // exp) % 10",
      "        count[index] += 1",
      "    for i in range(1, 10):",
      "        count[i] += count[i - 1]",
      "    i = n - 1",
      "    while i >= 0:",
      "        index = (arr[i] // exp) % 10",
      "        output[count[index] - 1] = arr[i]",
      "        count[index] -= 1",
      "        i -= 1",
      "    for i in range(n):",
      "        arr[i] = output[i]",
      "",
      "def radix_sort(arr):",
      "    max_val = max(arr)",
      "    exp = 1",
      "    while max_val // exp > 0:",
      "        counting_sort_for_radix(arr, exp)",
      "        exp *= 10",
      "    return arr"
    ],
    "description": "Tri par base pour trier une liste."
  },
  "DSA_Merge_Sort": {
    "prefix": ".dsa merge sort",
    "body": [
      "def merge_sort(arr):",
      "    if len(arr) > 1:",
      "        mid = len(arr) // 2",
      "        left = arr[:mid]",
      "        right = arr[mid:]",
      "        merge_sort(left)",
      "        merge_sort(right)",
      "        i = j = k = 0",
      "        while i < len(left) and j < len(right):",
      "            if left[i] < right[j]:",
      "                arr[k] = left[i]",
      "                i += 1",
      "            else:",
      "                arr[k] = right[j]",
      "                j += 1",
      "            k += 1",
      "        while i < len(left):",
      "            arr[k] = left[i]",
      "            i += 1",
      "            k += 1",
      "        while j < len(right):",
      "            arr[k] = right[j]",
      "            j += 1",
      "            k += 1",
      "    return arr"
    ],
    "description": "Tri fusion pour trier une liste."
  },
  "DSA_Linear_Search": {
    "prefix": ".dsa linear search",
    "body": [
      "def linear_search(arr, target):",
      "    for i in range(len(arr)):",
      "        if arr[i] == target:",
      "            return i",
      "    return -1"
    ],
    "description": "Recherche linéaire dans une liste."
  },
  "DSA_Binary_Search": {
    "prefix": ".dsa binary search",
    "body": [
      "def binary_search(arr, target):",
      "    left, right = 0, len(arr) - 1",
      "    while left <= right:",
      "        mid = (left + right) // 2",
      "        if arr[mid] == target:",
      "            return mid",
      "        elif arr[mid] < target:",
      "            left = mid + 1",
      "        else:",
      "            right = mid - 1",
      "    return -1"
    ],
    "description": "Recherche binaire dans une liste triée."
  },
  "DSA_Linked_Lists": {
    "prefix": ".dsa linked lists",
    "body": [
      "class Node:",
      "    def __init__(self, data):",
      "        self.data = data",
      "        self.next = None",
      "",
      "class LinkedList:",
      "    def __init__(self):",
      "        self.head = None",
      "",
      "    def append(self, data):",
      "        new_node = Node(data)",
      "        if not self.head:",
      "            self.head = new_node",
      "            return",
      "        current = self.head",
      "        while current.next:",
      "            current = current.next",
      "        current.next = new_node",
      "",
      "    def display(self):",
      "        current = self.head",
      "        while current:",
      "            print(current.data, end=' -> ')",
      "            current = current.next",
      "        print('None')"
    ],
    "description": "Créer une liste chaînée simple avec des opérations de base."
  },
  "DSA_Linked_Lists_in_Memory": {
    "prefix": ".dsa linked lists memory",
    "body": [
      "# Les listes chaînées sont représentées en mémoire comme une série de nœuds.",
      "# Chaque nœud contient des données et une référence au nœud suivant.",
      "# Exemple :",
      "class Node:",
      "    def __init__(self, data):",
      "        self.data = data",
      "        self.next = None",
      "",
      "# Les nœuds sont reliés pour former une structure de liste chaînée.",
      "node1 = Node(10)",
      "node2 = Node(20)",
      "node1.next = node2",
      "# node1 -> node2 -> None"
    ],
    "description": "Représentation des listes chaînées en mémoire."
  },
  "DSA_Linked_Lists_Types": {
    "prefix": ".dsa linked lists types",
    "body": [
      "# Types de listes chaînées :",
      "# 1. Liste chaînée simple : chaque nœud pointe vers le suivant.",
      "# 2. Liste chaînée double : chaque nœud pointe vers le précédent et le suivant.",
      "# 3. Liste chaînée circulaire : le dernier nœud pointe vers le premier.",
      "",
      "# Exemple de liste chaînée double :",
      "class DoublyNode:",
      "    def __init__(self, data):",
      "        self.data = data",
      "        self.next = None",
      "        self.prev = None",
      "",
      "class DoublyLinkedList:",
      "    def __init__(self):",
      "        self.head = None",
      "",
      "    def append(self, data):",
      "        new_node = DoublyNode(data)",
      "        if not self.head:",
      "            self.head = new_node",
      "            return",
      "        current = self.head",
      "        while current.next:",
      "            current = current.next",
      "        current.next = new_node",
      "        new_node.prev = current"
    ],
    "description": "Différents types de listes chaînées."
  },
  "Linked_Lists_Operations": {
    "prefix": ".dsa linked lists operations",
    "body": [
      "# Opérations sur les listes chaînées :",
      "# 1. Insertion : Ajouter un nœud au début, à la fin ou à une position spécifique.",
      "# 2. Suppression : Supprimer un nœud par valeur ou par position.",
      "# 3. Recherche : Trouver un nœud avec une valeur donnée.",
      "# 4. Affichage : Parcourir et afficher les éléments de la liste.",
      "",
      "# Exemple d'insertion au début :",
      "class LinkedList:",
      "    def __init__(self):",
      "        self.head = None",
      "",
      "    def insert_at_beginning(self, data):",
      "        new_node = Node(data)",
      "        new_node.next = self.head",
      "        self.head = new_node",
      "",
      "# Exemple de suppression par valeur :",
      "    def delete_by_value(self, value):",
      "        if not self.head:",
      "            return",
      "        if self.head.data == value:",
      "            self.head = self.head.next",
      "            return",
      "        current = self.head",
      "        while current.next and current.next.data != value:",
      "            current = current.next",
      "        if current.next:",
      "            current.next = current.next.next"
    ],
    "description": "Opérations courantes sur les listes chaînées."
  },
  "DSA_Stacks": {
    "prefix": ".dsa stacks",
    "body": [
      "class Stack:",
      "    def __init__(self):",
      "        self.stack = []",
      "",
      "    def push(self, item):",
      "        self.stack.append(item)",
      "",
      "    def pop(self):",
      "        if not self.is_empty():",
      "            return self.stack.pop()",
      "        return 'Stack is empty'",
      "",
      "    def peek(self):",
      "        if not self.is_empty():",
      "            return self.stack[-1]",
      "        return 'Stack is empty'",
      "",
      "    def is_empty(self):",
      "        return len(self.stack) == 0",
      "",
      "    def display(self):",
      "        print(self.stack)"
    ],
    "description": "Créer une pile avec des opérations de base."
  },
  "DSA_Queues": {
    "prefix": ".dsa queues",
    "body": [
      "class Queue:",
      "    def __init__(self):",
      "        self.queue = []",
      "",
      "    def enqueue(self, item):",
      "        self.queue.append(item)",
      "",
      "    def dequeue(self):",
      "        if not self.is_empty():",
      "            return self.queue.pop(0)",
      "        return 'Queue is empty'",
      "",
      "    def peek(self):",
      "        if not self.is_empty():",
      "            return self.queue[0]",
      "        return 'Queue is empty'",
      "",
      "    def is_empty(self):",
      "        return len(self.queue) == 0",
      "",
      "    def display(self):",
      "        print(self.queue)"
    ],
    "description": "Créer une file avec des opérations de base."
  },
  "DSA_Hash_Tables": {
    "prefix": ".dsa hash tables",
    "body": [
      "class HashTable:",
      "    def __init__(self):",
      "        self.table = [None] * 10",
      "",
      "    def hash_function(self, key):",
      "        return hash(key) % len(self.table)",
      "",
      "    def insert(self, key, value):",
      "        index = self.hash_function(key)",
      "        if self.table[index] is None:",
      "            self.table[index] = []",
      "        self.table[index].append((key, value))",
      "",
      "    def search(self, key):",
      "        index = self.hash_function(key)",
      "        if self.table[index] is not None:",
      "            for k, v in self.table[index]:",
      "                if k == key:",
      "                    return v",
      "        return None",
      "",
      "    def delete(self, key):",
      "        index = self.hash_function(key)",
      "        if self.table[index] is not None:",
      "            self.table[index] = [pair for pair in self.table[index] if pair[0] != key]"
    ],
    "description": "Créer une table de hachage avec des opérations de base."
  },
  "DSA_Hash_Sets": {
    "prefix": ".dsa hash sets",
    "body": [
      "class HashSet:",
      "    def __init__(self):",
      "        self.set = set()",
      "",
      "    def add(self, value):",
      "        self.set.add(value)",
      "",
      "    def remove(self, value):",
      "        self.set.discard(value)",
      "",
      "    def contains(self, value):",
      "        return value in self.set",
      "",
      "    def display(self):",
      "        print(self.set)"
    ],
    "description": "Créer un ensemble de hachage avec des opérations de base."
  },
  "DSA_Hash_Maps": {
    "prefix": ".dsa hash maps",
    "body": [
      "class HashMap:",
      "    def __init__(self):",
      "        self.map = {}",
      "",
      "    def put(self, key, value):",
      "        self.map[key] = value",
      "",
      "    def get(self, key):",
      "        return self.map.get(key, None)",
      "",
      "    def remove(self, key):",
      "        if key in self.map:",
      "            del self.map[key]",
      "",
      "    def display(self):",
      "        print(self.map)"
    ],
    "description": "Créer une carte de hachage avec des opérations de base."
  },
  "DSA_Trees": {
    "prefix": ".dsa trees",
    "body": [
      "class TreeNode:",
      "    def __init__(self, data):",
      "        self.data = data",
      "        self.children = []",
      "",
      "    def add_child(self, child):",
      "        self.children.append(child)",
      "",
      "    def display(self, level=0):",
      "        print(' ' * level * 2 + str(self.data))",
      "        for child in self.children:",
      "            child.display(level + 1)"
    ],
    "description": "Créer une structure d'arbre générique."
  },
  "DSA_Binary_Trees": {
    "prefix": ".dsa binary trees",
    "body": [
      "class BinaryTreeNode:",
      "    def __init__(self, data):",
      "        self.data = data",
      "        self.left = None",
      "        self.right = None",
      "",
      "    def insert_left(self, data):",
      "        self.left = BinaryTreeNode(data)",
      "",
      "    def insert_right(self, data):",
      "        self.right = BinaryTreeNode(data)"
    ],
    "description": "Créer une structure d'arbre binaire."
  },
  "DSA_Preorder_Traversal": {
    "prefix": ".dsa preorder traversal",
    "body": [
      "def preorder_traversal(root):",
      "    if root:",
      "        print(root.data, end=' ')",
      "        preorder_traversal(root.left)",
      "        preorder_traversal(root.right)"
    ],
    "description": "Parcours préfixe d'un arbre binaire."
  },
  "DSA_Inorder_Traversal": {
    "prefix": ".dsa inorder traversal",
    "body": [
      "def inorder_traversal(root):",
      "    if root:",
      "        inorder_traversal(root.left)",
      "        print(root.data, end=' ')",
      "        inorder_traversal(root.right)"
    ],
    "description": "Parcours infixe d'un arbre binaire."
  },
  "DSA_Postorder_Traversal": {
    "prefix": ".dsa postorder traversal",
    "body": [
      "def postorder_traversal(root):",
      "    if root:",
      "        postorder_traversal(root.left)",
      "        postorder_traversal(root.right)",
      "        print(root.data, end=' ')"
    ],
    "description": "Parcours postfixe d'un arbre binaire."
  },
  "DSA_Array_Implementation": {
    "prefix": ".dsa array implementation",
    "body": [
      "class ArrayBinaryTree:",
      "    def __init__(self):",
      "        self.tree = []",
      "",
      "    def insert(self, data):",
      "        self.tree.append(data)",
      "",
      "    def get_left_child(self, index):",
      "        left_index = 2 * index + 1",
      "        return self.tree[left_index] if left_index < len(self.tree) else None",
      "",
      "    def get_right_child(self, index):",
      "        right_index = 2 * index + 2",
      "        return self.tree[right_index] if right_index < len(self.tree) else None"
    ],
    "description": "Implémentation d'un arbre binaire avec un tableau."
  },
  "DSA_Binary_Search_Trees": {
    "prefix": ".dsa binary search trees",
    "body": [
      "class BSTNode:",
      "    def __init__(self, data):",
      "        self.data = data",
      "        self.left = None",
      "        self.right = None",
      "",
      "    def insert(self, data):",
      "        if data < self.data:",
      "            if self.left is None:",
      "                self.left = BSTNode(data)",
      "            else:",
      "                self.left.insert(data)",
      "        elif data > self.data:",
      "            if self.right is None:",
      "                self.right = BSTNode(data)",
      "            else:",
      "                self.right.insert(data)"
    ],
    "description": "Créer un arbre binaire de recherche (BST)."
  },
  "DSA_AVL_Trees": {
    "prefix": ".dsa avl trees",
    "body": [
      "class AVLNode:",
      "    def __init__(self, data):",
      "        self.data = data",
      "        self.left = None",
      "        self.right = None",
      "        self.height = 1",
      "",
      "def get_height(node):",
      "    return node.height if node else 0",
      "",
      "def rotate_right(y):",
      "    x = y.left",
      "    T2 = x.right",
      "    x.right = y",
      "    y.left = T2",
      "    y.height = 1 + max(get_height(y.left), get_height(y.right))",
      "    x.height = 1 + max(get_height(x.left), get_height(x.right))",
      "    return x",
      "",
      "def rotate_left(x):",
      "    y = x.right",
      "    T2 = y.left",
      "    y.left = x",
      "    x.right = T2",
      "    x.height = 1 + max(get_height(x.left), get_height(x.right))",
      "    y.height = 1 + max(get_height(y.left), get_height(y.right))",
      "    return y",
      "",
      "def get_balance(node):",
      "    return get_height(node.left) - get_height(node.right) if node else 0",
      "",
      "def insert_avl(root, data):",
      "    if not root:",
      "        return AVLNode(data)",
      "    if data < root.data:",
      "        root.left = insert_avl(root.left, data)",
      "    else:",
      "        root.right = insert_avl(root.right, data)",
      "    root.height = 1 + max(get_height(root.left), get_height(root.right))",
      "    balance = get_balance(root)",
      "    if balance > 1 and data < root.left.data:",
      "        return rotate_right(root)",
      "    if balance < -1 and data > root.right.data:",
      "        return rotate_left(root)",
      "    if balance > 1 and data > root.left.data:",
      "        root.left = rotate_left(root.left)",
      "        return rotate_right(root)",
      "    if balance < -1 and data < root.right.data:",
      "        root.right = rotate_right(root.right)",
      "        return rotate_left(root)",
      "    return root"
    ],
    "description": "Créer un arbre AVL avec équilibrage automatique."
  },
  "DSA_Graphs": {
    "prefix": ".dsa graphs",
    "body": [
      "class Graph:",
      "    def __init__(self):",
      "        self.graph = {}",
      "",
      "    def add_edge(self, u, v):",
      "        if u not in self.graph:",
      "            self.graph[u] = []",
      "        self.graph[u].append(v)",
      "",
      "    def display(self):",
      "        for node in self.graph:",
      "            print(f\"{node} -> {self.graph[node]}\")"
    ],
    "description": "Créer un graphe avec des opérations de base."
  },
  "Graphs_Implementation": {
    "prefix": ".dsa graphs implementation",
    "body": [
      "class Graph:",
      "    def __init__(self, vertices):",
      "        self.vertices = vertices",
      "        self.adj_list = {i: [] for i in range(vertices)}",
      "",
      "    def add_edge(self, u, v):",
      "        self.adj_list[u].append(v)",
      "        self.adj_list[v].append(u)  # Pour un graphe non orienté",
      "",
      "    def display(self):",
      "        for vertex, edges in self.adj_list.items():",
      "            print(f\"{vertex}: {edges}\")"
    ],
    "description": "Implémentation d'un graphe avec une liste d'adjacence."
  },
  "DSA_Graphs_Traversal": {
    "prefix": ".dsa graphs traversal",
    "body": [
      "def dfs(graph, start, visited=None):",
      "    if visited is None:",
      "        visited = set()",
      "    visited.add(start)",
      "    print(start, end=' ')",
      "    for neighbor in graph[start]:",
      "        if neighbor not in visited:",
      "            dfs(graph, neighbor, visited)",
      "",
      "def bfs(graph, start):",
      "    visited = set()",
      "    queue = [start]",
      "    visited.add(start)",
      "    while queue:",
      "        vertex = queue.pop(0)",
      "        print(vertex, end=' ')",
      "        for neighbor in graph[vertex]:",
      "            if neighbor not in visited:",
      "                visited.add(neighbor)",
      "                queue.append(neighbor)"
    ],
    "description": "Parcours DFS et BFS d'un graphe."
  },
  "DSA_Cycle_Detection": {
    "prefix": ".dsa cycle detection",
    "body": [
      "def is_cyclic_util(graph, v, visited, parent):",
      "    visited[v] = True",
      "    for neighbor in graph[v]:",
      "        if not visited[neighbor]:",
      "            if is_cyclic_util(graph, neighbor, visited, v):",
      "                return True",
      "        elif parent != neighbor:",
      "            return True",
      "    return False",
      "",
      "def is_cyclic(graph, vertices):",
      "    visited = [False] * vertices",
      "    for i in range(vertices):",
      "        if not visited[i]:",
      "            if is_cyclic_util(graph, i, visited, -1):",
      "                return True",
      "    return False"
    ],
    "description": "Détection de cycle dans un graphe non orienté."
  },
  "DSA_Shortest_Path": {
    "prefix": ".dsa shortest path",
    "body": [
      "def shortest_path(graph, start, end):",
      "    visited = set()",
      "    queue = [(start, [start])]",
      "    while queue:",
      "        (vertex, path) = queue.pop(0)",
      "        if vertex not in visited:",
      "            if vertex == end:",
      "                return path",
      "            visited.add(vertex)",
      "            for neighbor in graph[vertex]:",
      "                queue.append((neighbor, path + [neighbor]))",
      "    return None"
    ],
    "description": "Trouver le chemin le plus court dans un graphe non pondéré."
  },
  "DSA_Dijkstra": {
    "prefix": ".dsa dijkstra",
    "body": [
      "import heapq",
      "",
      "def dijkstra(graph, start):",
      "    distances = {vertex: float('infinity') for vertex in graph}",
      "    distances[start] = 0",
      "    priority_queue = [(0, start)]",
      "",
      "    while priority_queue:",
      "        current_distance, current_vertex = heapq.heappop(priority_queue)",
      "",
      "        if current_distance > distances[current_vertex]:",
      "            continue",
      "",
      "        for neighbor, weight in graph[current_vertex].items():",
      "            distance = current_distance + weight",
      "            if distance < distances[neighbor]:",
      "                distances[neighbor] = distance",
      "                heapq.heappush(priority_queue, (distance, neighbor))",
      "",
      "    return distances"
    ],
    "description": "Trouver le chemin le plus court avec l'algorithme de Dijkstra."
  },
  "DSA_Bellman_Ford": {
    "prefix": ".dsa bellman ford",
    "body": [
      "def bellman_ford(graph, vertices, start):",
      "    distances = [float('infinity')] * vertices",
      "    distances[start] = 0",
      "",
      "    for _ in range(vertices - 1):",
      "        for u, v, weight in graph:",
      "            if distances[u] + weight < distances[v]:",
      "                distances[v] = distances[u] + weight",
      "",
      "    for u, v, weight in graph:",
      "        if distances[u] + weight < distances[v]:",
      "            return 'Graph contains a negative-weight cycle'",
      "",
      "    return distances"
    ],
    "description": "Trouver le chemin le plus court avec l'algorithme de Bellman-Ford."
  },
  "DSA_Prims": {
    "prefix": ".dsa prims",
    "body": [
      "import heapq",
      "",
      "def prims(graph, start):",
      "    mst = []",
      "    visited = set()",
      "    min_heap = [(0, start, None)]",
      "",
      "    while min_heap:",
      "        weight, current, parent = heapq.heappop(min_heap)",
      "        if current not in visited:",
      "            visited.add(current)",
      "            if parent is not None:",
      "                mst.append((parent, current, weight))",
      "            for neighbor, edge_weight in graph[current]:",
      "                if neighbor not in visited:",
      "                    heapq.heappush(min_heap, (edge_weight, neighbor, current))",
      "",
      "    return mst"
    ],
    "description": "Trouver l'arbre couvrant minimal avec l'algorithme de Prim."
  },
  "DSA_Kruskals": {
    "prefix": ".dsa kruskals",
    "body": [
      "class DisjointSet:",
      "    def __init__(self, vertices):",
      "        self.parent = {v: v for v in vertices}",
      "        self.rank = {v: 0 for v in vertices}",
      "",
      "    def find(self, v):",
      "        if self.parent[v] != v:",
      "            self.parent[v] = self.find(self.parent[v])",
      "        return self.parent[v]",
      "",
      "    def union(self, u, v):",
      "        root_u = self.find(u)",
      "        root_v = self.find(v)",
      "        if root_u != root_v:",
      "            if self.rank[root_u] > self.rank[root_v]:",
      "                self.parent[root_v] = root_u",
      "            elif self.rank[root_u] < self.rank[root_v]:",
      "                self.parent[root_u] = root_v",
      "            else:",
      "                self.parent[root_v] = root_u",
      "                self.rank[root_u] += 1",
      "",
      "def kruskals(vertices, edges):",
      "    ds = DisjointSet(vertices)",
      "    mst = []",
      "    edges.sort(key=lambda x: x[2])",
      "",
      "    for u, v, weight in edges:",
      "        if ds.find(u) != ds.find(v):",
      "            ds.union(u, v)",
      "            mst.append((u, v, weight))",
      "",
      "    return mst"
    ],
    "description": "Trouver l'arbre couvrant minimal avec l'algorithme de Kruskal."
  },
  "DSA_Maximum_Flow": {
    "prefix": ".dsa maximum flow",
    "body": [
      "class Graph:",
      "    def __init__(self, vertices):",
      "        self.vertices = vertices",
      "        self.graph = [[0] * vertices for _ in range(vertices)]",
      "",
      "    def add_edge(self, u, v, capacity):",
      "        self.graph[u][v] = capacity",
      "",
      "    def bfs(self, source, sink, parent):",
      "        visited = [False] * self.vertices",
      "        queue = [source]",
      "        visited[source] = True",
      "",
      "        while queue:",
      "            u = queue.pop(0)",
      "            for v, capacity in enumerate(self.graph[u]):",
      "                if not visited[v] and capacity > 0:",
      "                    queue.append(v)",
      "                    visited[v] = True",
      "                    parent[v] = u",
      "                    if v == sink:",
      "                        return True",
      "        return False",
      "",
      "    def ford_fulkerson(self, source, sink):",
      "        parent = [-1] * self.vertices",
      "        max_flow = 0",
      "",
      "        while self.bfs(source, sink, parent):",
      "            path_flow = float('Inf')",
      "            s = sink",
      "            while s != source:",
      "                path_flow = min(path_flow, self.graph[parent[s]][s])",
      "                s = parent[s]",
      "",
      "            max_flow += path_flow",
      "            v = sink",
      "            while v != source:",
      "                u = parent[v]",
      "                self.graph[u][v] -= path_flow",
      "                self.graph[v][u] += path_flow",
      "                v = parent[v]",
      "",
      "        return max_flow"
    ],
    "description": "Calculer le flux maximum avec l'algorithme de Ford-Fulkerson."
  },
  "DSA_Ford_Fulkerson": {
    "prefix": ".dsa ford fulkerson",
    "body": [
      "class Graph:",
      "    def __init__(self, vertices):",
      "        self.vertices = vertices",
      "        self.graph = [[0] * vertices for _ in range(vertices)]",
      "",
      "    def add_edge(self, u, v, capacity):",
      "        self.graph[u][v] = capacity",
      "",
      "    def bfs(self, source, sink, parent):",
      "        visited = [False] * self.vertices",
      "        queue = [source]",
      "        visited[source] = True",
      "",
      "        while queue:",
      "            u = queue.pop(0)",
      "            for v, capacity in enumerate(self.graph[u]):",
      "                if not visited[v] and capacity > 0:",
      "                    queue.append(v)",
      "                    visited[v] = True",
      "                    parent[v] = u",
      "                    if v == sink:",
      "                        return True",
      "        return False",
      "",
      "    def ford_fulkerson(self, source, sink):",
      "        parent = [-1] * self.vertices",
      "        max_flow = 0",
      "",
      "        while self.bfs(source, sink, parent):",
      "            path_flow = float('Inf')",
      "            s = sink",
      "            while s != source:",
      "                path_flow = min(path_flow, self.graph[parent[s]][s])",
      "                s = parent[s]",
      "",
      "            max_flow += path_flow",
      "            v = sink",
      "            while v != source:",
      "                u = parent[v]",
      "                self.graph[u][v] -= path_flow",
      "                self.graph[v][u] += path_flow",
      "                v = parent[v]",
      "",
      "        return max_flow"
    ],
    "description": "Implémentation de l'algorithme de Ford-Fulkerson pour le flux maximum."
  },
  "DSA_Edmonds_Karp": {
    "prefix": ".dsa edmonds karp",
    "body": [
      "from collections import deque",
      "",
      "class Graph:",
      "    def __init__(self, vertices):",
      "        self.vertices = vertices",
      "        self.graph = [[0] * vertices for _ in range(vertices)]",
      "",
      "    def add_edge(self, u, v, capacity):",
      "        self.graph[u][v] = capacity",
      "",
      "    def bfs(self, source, sink, parent):",
      "        visited = [False] * self.vertices",
      "        queue = deque([source])",
      "        visited[source] = True",
      "",
      "        while queue:",
      "            u = queue.popleft()",
      "            for v, capacity in enumerate(self.graph[u]):",
      "                if not visited[v] and capacity > 0:",
      "                    queue.append(v)",
      "                    visited[v] = True",
      "                    parent[v] = u",
      "                    if v == sink:",
      "                        return True",
      "        return False",
      "",
      "    def edmonds_karp(self, source, sink):",
      "        parent = [-1] * self.vertices",
      "        max_flow = 0",
      "",
      "        while self.bfs(source, sink, parent):",
      "            path_flow = float('Inf')",
      "            s = sink",
      "            while s != source:",
      "                path_flow = min(path_flow, self.graph[parent[s]][s])",
      "                s = parent[s]",
      "",
      "            max_flow += path_flow",
      "            v = sink",
      "            while v != source:",
      "                u = parent[v]",
      "                self.graph[u][v] -= path_flow",
      "                self.graph[v][u] += path_flow",
      "                v = parent[v]",
      "",
      "        return max_flow"
    ],
    "description": "Calculer le flux maximum avec l'algorithme d'Edmonds-Karp."
  },
  "mysql_connect": {
    "prefix": ".mysql connect",
    "body": [
      "import mysql.connector",
      "",
      "connection = mysql.connector.connect(",
      "    host='$1',",
      "    user='$2',",
      "    password='$3',",
      "    database='$4'",
      ")",
      "cursor = connection.cursor()"
    ],
    "description": "Se connecter à une base de données MySQL"
  },
  "mysql_create_database": {
    "prefix": ".mysql create database",
    "body": [
      "cursor.execute('''",
      "CREATE DATABASE $1",
      "''')"
    ],
    "description": "Créer une base de données MySQL"
  },
  "mysql_create_table": {
    "prefix": ".mysql create table",
    "body": [
      "cursor.execute('''",
      "CREATE TABLE $1 (",
      "    $2 $3,",
      "    $4 $5",
      ")",
      "''')"
    ],
    "description": "Créer une table dans MySQL"
  },
  "mysql_insert": {
    "prefix": ".mysql insert",
    "body": [
      "cursor.execute('''",
      "INSERT INTO $1 ($2) VALUES ($3)",
      "''')",
      "connection.commit()"
    ],
    "description": "Insérer des données dans une table MySQL"
  },
  "mysql_select": {
    "prefix": ".mysql select",
    "body": [
      "cursor.execute('''",
      "SELECT $1 FROM $2 WHERE $3",
      "''')",
      "result = cursor.fetchall()",
      "for row in result:",
      "    print(row)"
    ],
    "description": "Sélectionner des données dans une table MySQL"
  },
  "mysql_where": {
    "prefix": ".mysql where",
    "body": [
      "cursor.execute('''",
      "SELECT $1 FROM $2 WHERE $3",
      "''')",
      "result = cursor.fetchall()",
      "for row in result:",
      "    print(row)"
    ],
    "description": "Utiliser une clause WHERE dans une requête MySQL"
  },
  "mysql_order_by": {
    "prefix": ".mysql order by",
    "body": [
      "cursor.execute('''",
      "SELECT $1 FROM $2 ORDER BY $3 $4",
      "''')",
      "result = cursor.fetchall()",
      "for row in result:",
      "    print(row)"
    ],
    "description": "Utiliser une clause ORDER BY dans une requête MySQL"
  },
  "mysql_delete": {
    "prefix": ".mysql delete",
    "body": [
      "cursor.execute('''",
      "DELETE FROM $1 WHERE $2",
      "''')",
      "connection.commit()"
    ],
    "description": "Supprimer des données dans une table MySQL"
  },
  "mysql_drop_table": {
    "prefix": ".mysql drop table",
    "body": [
      "cursor.execute('''",
      "DROP TABLE $1",
      "''')"
    ],
    "description": "Supprimer une table dans MySQL"
  },
  "mysql_update": {
    "prefix": ".mysql update",
    "body": [
      "cursor.execute('''",
      "UPDATE $1 SET $2 = $3 WHERE $4",
      "''')",
      "connection.commit()"
    ],
    "description": "Mettre à jour des données dans une table MySQL"
  },
  "mysql_limit": {
    "prefix": ".mysql limit",
    "body": [
      "cursor.execute('''",
      "SELECT $1 FROM $2 LIMIT $3",
      "''')",
      "result = cursor.fetchall()",
      "for row in result:",
      "    print(row)"
    ],
    "description": "Limiter le nombre de résultats dans une requête MySQL"
  },
  "mysql_join": {
    "prefix": ".mysql join",
    "body": [
      "cursor.execute('''",
      "SELECT $1 FROM $2 INNER JOIN $3 ON $2.$4 = $3.$5",
      "''')",
      "result = cursor.fetchall()",
      "for row in result:",
      "    print(row)"
    ],
    "description": "Effectuer une jointure entre deux tables dans MySQL"
  },
  "mysql_close": {
    "prefix": ".mysql close",
    "body": [
      "cursor.close()",
      "connection.close()"
    ],
    "description": "Fermer la connexion à la base de données MySQL"
  },
  "json_load": {
    "prefix": ".json load",
    "body": [
      "import json",
      "with open('$1', 'r') as file:",
      "    data = json.load(file)"
    ],
    "description": "Charger un fichier JSON"
  },
  "json_dump": {
    "prefix": ".json dump",
    "body": [
      "import json",
      "with open('$1', 'w') as file:",
      "    json.dump($2, file, indent=4)"
    ],
    "description": "Écrire des données dans un fichier JSON"
  },
  "json_loads": {
    "prefix": ".json loads",
    "body": [
      "import json",
      "data = json.loads('$1')"
    ],
    "description": "Convertir une chaîne JSON en objet Python"
  },
  "json_dumps": {
    "prefix": ".json dumps",
    "body": [
      "import json",
      "json_string = json.dumps($1, indent=4)"
    ],
    "description": "Convertir un objet Python en chaîne JSON"
  },
  "json_update": {
    "prefix": ".json update",
    "body": [
      "data['$1'] = $2"
    ],
    "description": "Mettre à jour une clé dans un objet JSON"
  },
  "json_delete_key": {
    "prefix": ".json delete key",
    "body": [
      "del data['$1']"
    ],
    "description": "Supprimer une clé d'un objet JSON"
  },
  "json_get_value": {
    "prefix": ".json get value",
    "body": [
      "value = data.get('$1', '$2')"
    ],
    "description": "Obtenir une valeur d'un objet JSON avec une valeur par défaut"
  },
  "json_iterate": {
    "prefix": ".json iterate",
    "body": [
      "for key, value in data.items():",
      "    print(key, value)"
    ],
    "description": "Parcourir les clés et valeurs d'un objet JSON"
  },
  "json_check_key": {
    "prefix": ".json check key",
    "body": [
      "if '$1' in data:",
      "    print('Key exists')"
    ],
    "description": "Vérifier si une clé existe dans un objet JSON"
  },
  "json_merge": {
    "prefix": ".json merge",
    "body": [
      "data.update($1)"
    ],
    "description": "Fusionner deux objets JSON"
  },
  "mongodb_connect": {
    "prefix": ".mongodb connect",
    "body": [
      "from pymongo import MongoClient",
      "",
      "client = MongoClient('$1')",
      "db = client['$2']"
    ],
    "description": "Se connecter à une base de données MongoDB"
  },
  "mongodb_insert_one": {
    "prefix": ".mongodb insert one",
    "body": [
      "db['$1'].insert_one({",
      "    '$2': '$3',",
      "    '$4': '$5'",
      "})"
    ],
    "description": "Insérer un document dans une collection MongoDB"
  },
  "mongodb_insert_many": {
    "prefix": ".mongodb insert many",
    "body": [
      "db['$1'].insert_many([",
      "    { '$2': '$3', '$4': '$5' },",
      "    { '$6': '$7', '$8': '$9' }",
      "])"
    ],
    "description": "Insérer plusieurs documents dans une collection MongoDB"
  },
  "mongodb_find_one": {
    "prefix": ".mongodb find one",
    "body": [
      "result = db['$1'].find_one({ '$2': '$3' })",
      "print(result)"
    ],
    "description": "Trouver un document dans une collection MongoDB"
  },
  "mongodb_find_many": {
    "prefix": ".mongodb find many",
    "body": [
      "results = db['$1'].find({ '$2': '$3' })",
      "for document in results:",
      "    print(document)"
    ],
    "description": "Trouver plusieurs documents dans une collection MongoDB"
  },
  "mongodb_update_one": {
    "prefix": ".mongodb update one",
    "body": [
      "db['$1'].update_one({ '$2': '$3' }, { '$4': { '$5': '$6' } })"
    ],
    "description": "Mettre à jour un document dans une collection MongoDB"
  },
  "mongodb_update_many": {
    "prefix": ".mongodb update many",
    "body": [
      "db['$1'].update_many({ '$2': '$3' }, { '$4': { '$5': '$6' } })"
    ],
    "description": "Mettre à jour plusieurs documents dans une collection MongoDB"
  },
  "mongodb_delete_one": {
    "prefix": ".mongodb delete one",
    "body": [
      "db['$1'].delete_one({ '$2': '$3' })"
    ],
    "description": "Supprimer un document dans une collection MongoDB"
  },
  "mongodb_delete_many": {
    "prefix": ".mongodb delete many",
    "body": [
      "db['$1'].delete_many({ '$2': '$3' })"
    ],
    "description": "Supprimer plusieurs documents dans une collection MongoDB"
  },
  "mongodb_create_index": {
    "prefix": ".mongodb create index",
    "body": [
      "db['$1'].create_index('$2')"
    ],
    "description": "Créer un index dans une collection MongoDB"
  },
  "mongodb_aggregate": {
    "prefix": ".mongodb aggregate",
    "body": [
      "pipeline = [",
      "    { '$match': { '$1': '$2' } },",
      "    { '$group': { '_id': '$3', 'total': { '$sum': '$4' } } }",
      "]",
      "results = db['$5'].aggregate(pipeline)",
      "for result in results:",
      "    print(result)"
    ],
    "description": "Effectuer une agrégation dans une collection MongoDB"
  },
  "BeautifulSoup_import": {
    "prefix": ".BeautifulSoup import",
    "body": [
      "from bs4 import BeautifulSoup",
      "import requests"
    ],
    "description": "Importer BeautifulSoup et requests"
  },
  "BeautifulSoup_load_html": {
    "prefix": ".BeautifulSoup load html",
    "body": [
      "# Charger une page HTML (locale ou via requests)",
      "url = \"$1\"",
      "response = requests.get(url)",
      "html_content = response.text",
      "soup = BeautifulSoup(html_content, 'html.parser')"
    ],
    "description": "Charger une page HTML avec BeautifulSoup"
  },
  "BeautifulSoup_find": {
    "prefix": ".BeautifulSoup find",
    "body": [
      "# Utiliser .find() et .find_all()",
      "element = soup.find('$1')",
      "elements = soup.find_all('$2')"
    ],
    "description": "Trouver des éléments HTML avec BeautifulSoup"
  },
  "BeautifulSoup_extract_text": {
    "prefix": ".BeautifulSoup extract text",
    "body": [
      "# Extraire le texte avec .text",
      "text = element.text.strip()"
    ],
    "description": "Extraire le texte d'un élément HTML"
  },
  "BeautifulSoup_access_attributes": {
    "prefix": ".BeautifulSoup access attributes",
    "body": [
      "# Accéder aux attributs avec .attrs",
      "attributes = element.attrs"
    ],
    "description": "Accéder aux attributs d'un élément HTML"
  },
  "BeautifulSoup_select": {
    "prefix": ".BeautifulSoup select",
    "body": [
      "# Utiliser .select() avec des sélecteurs CSS",
      "selected_elements = soup.select('$1')"
    ],
    "description": "Sélectionner des éléments avec des sélecteurs CSS"
  },
  "BeautifulSoup_dom_navigation": {
    "prefix": ".BeautifulSoup dom navigation",
    "body": [
      "# Naviguer dans le DOM (.parent, .children, .next_sibling)",
      "parent = element.parent",
      "children = list(element.children)",
      "next_sibling = element.next_sibling"
    ],
    "description": "Naviguer dans le DOM avec BeautifulSoup"
  },
  "BeautifulSoup_clean_data": {
    "prefix": ".BeautifulSoup clean data",
    "body": [
      "# Nettoyer les données (.strip(), etc.)",
      "cleaned_text = text.strip()"
    ],
    "description": "Nettoyer les données extraites"
  },
  "BeautifulSoup_extract_table": {
    "prefix": ".BeautifulSoup extract table",
    "body": [
      "# Extraire des tableaux HTML",
      "table = soup.find('table')",
      "rows = table.find_all('tr')"
    ],
    "description": "Extraire des tableaux HTML avec BeautifulSoup"
  },
  "BeautifulSoup_regex": {
    "prefix": ".BeautifulSoup regex",
    "body": [
      "# Utiliser re pour affiner les sélections",
      "import re",
      "pattern = re.compile('$1')",
      "filtered_elements = soup.find_all(string=pattern)"
    ],
    "description": "Utiliser des expressions régulières avec BeautifulSoup"
  },
  "BeautifulSoup_requests_session": {
    "prefix": ".BeautifulSoup requests session",
    "body": [
      "# Gérer les cookies et sessions (requests.Session)",
      "session = requests.Session()",
      "session.get(url)"
    ],
    "description": "Gérer les sessions avec requests"
  },
  "BeautifulSoup_custom_headers": {
    "prefix": ".BeautifulSoup custom headers",
    "body": [
      "# Utiliser des headers personnalisés (User-Agent)",
      "headers = {'User-Agent': 'Mozilla/5.0'}",
      "response = requests.get(url, headers=headers)"
    ],
    "description": "Utiliser des headers personnalisés avec requests"
  },
  "BeautifulSoup_error_handling": {
    "prefix": ".BeautifulSoup error handling",
    "body": [
      "# Gérer les erreurs et timeouts",
      "try:",
      "    response = requests.get(url, timeout=10)",
      "    response.raise_for_status()",
      "except requests.exceptions.RequestException as e:",
      "    print(f\"Error: {e}\")"
    ],
    "description": "Gérer les erreurs et timeouts avec requests"
  },
  "BeautifulSoup_with_selenium": {
    "prefix": ".BeautifulSoup with selenium",
    "body": [
      "# Utiliser BeautifulSoup avec du JavaScript (via Selenium ou Playwright)",
      "# from selenium import webdriver",
      "# driver = webdriver.Chrome()",
      "# driver.get(url)",
      "# html_content = driver.page_source",
      "# soup = BeautifulSoup(html_content, 'html.parser')"
    ],
    "description": "Utiliser BeautifulSoup avec Selenium"
  },
  "BeautifulSoup_export_csv": {
    "prefix": ".BeautifulSoup export csv",
    "body": [
      "# Exporter vers CSV",
      "import csv",
      "with open('output.csv', 'w', newline='') as csvfile:",
      "    writer = csv.writer(csvfile)",
      "    writer.writerow(['Column1', 'Column2'])",
      "    for row in rows:",
      "        writer.writerow([cell.text.strip() for cell in row.find_all('td')])"
    ],
    "description": "Exporter des données vers un fichier CSV"
  },
  "pdf_import": {
    "prefix": ".pdf import",
    "body": [
      "import fitz  # PyMuPDF"
    ],
    "description": "Importer la bibliothèque PyMuPDF"
  },
  "pdf_open": {
    "prefix": ".pdf open",
    "body": [
      "doc = fitz.open('$1')"
    ],
    "description": "Ouvrir un fichier PDF avec PyMuPDF"
  },
  "pdf_page_count": {
    "prefix": ".pdf page count",
    "body": [
      "page_count = doc.page_count"
    ],
    "description": "Obtenir le nombre de pages dans un PDF"
  },
  "pdf_get_page": {
    "prefix": ".pdf get page",
    "body": [
      "page = doc[$1]"
    ],
    "description": "Obtenir une page spécifique d'un PDF"
  },
  "pdf_extract_text": {
    "prefix": ".pdf extract text",
    "body": [
      "text = page.get_text()"
    ],
    "description": "Extraire le texte d'une page PDF"
  },
  "pdf_extract_images": {
    "prefix": ".pdf extract images",
    "body": [
      "images = page.get_images(full=True)"
    ],
    "description": "Extraire les images d'une page PDF"
  },
  "pdf_save_image": {
    "prefix": ".pdf save image",
    "body": [
      "pix = fitz.Pixmap(doc, $1)",
      "pix.save('$2')"
    ],
    "description": "Enregistrer une image extraite d'un PDF"
  },
  "pdf_search_text": {
    "prefix": ".pdf search text",
    "body": [
      "instances = page.search_for('$1')"
    ],
    "description": "Rechercher du texte dans une page PDF"
  },
  "pdf_highlight_text": {
    "prefix": ".pdf highlight text",
    "body": [
      "for inst in instances:",
      "    highlight = page.add_highlight_annot(inst)"
    ],
    "description": "Mettre en surbrillance du texte dans un PDF"
  },
  "pdf_add_text": {
    "prefix": ".pdf add text",
    "body": [
      "page.insert_text(($1, $2), '$3', fontsize=$4, color=($5, $6, $7))"
    ],
    "description": "Ajouter du texte à une page PDF"
  },
  "pdf_save": {
    "prefix": ".pdf save",
    "body": [
      "doc.save('$1')"
    ],
    "description": "Enregistrer les modifications apportées à un PDF"
  },
  "pdf_close": {
    "prefix": ".pdf close",
    "body": [
      "doc.close()"
    ],
    "description": "Fermer un fichier PDF"
  },
  "pdf_merge": {
    "prefix": ".pdf merge",
    "body": [
      "output = fitz.open()",
      "for pdf in ['$1', '$2']:",
      "    input_pdf = fitz.open(pdf)",
      "    for page in input_pdf:",
      "        output.insert_pdf(input_pdf)",
      "output.save('$3')"
    ],
    "description": "Fusionner plusieurs fichiers PDF"
  },
  "pdf_split": {
    "prefix": ".pdf split",
    "body": [
      "for page_num in range(doc.page_count):",
      "    new_doc = fitz.open()",
      "    new_doc.insert_pdf(doc, from_page=page_num, to_page=page_num)",
      "    new_doc.save(f'$1_page_{page_num + 1}.pdf')"
    ],
    "description": "Diviser un fichier PDF en plusieurs fichiers"
  },
  "pdf_rotate_page": {
    "prefix": ".pdf rotate page",
    "body": [
      "page.set_rotation($1)"
    ],
    "description": "Faire pivoter une page PDF"
  },
  "pdf_encrypt": {
    "prefix": ".pdf encrypt",
    "body": [
      "doc.save('$1', encryption=fitz.PDF_ENCRYPT_AES_256, owner_pw='$2', user_pw='$3')"
    ],
    "description": "Crypter un fichier PDF avec un mot de passe"
  },
  "pdf_decrypt": {
    "prefix": ".pdf decrypt",
    "body": [
      "doc.authenticate('$1')"
    ],
    "description": "Décrypter un fichier PDF avec un mot de passe"
  },
  "pdf_metadata": {
    "prefix": ".pdf metadata",
    "body": [
      "metadata = doc.metadata",
      "print(metadata)"
    ],
    "description": "Afficher les métadonnées d'un fichier PDF"
  },
  "pdf_add_image": {
    "prefix": ".pdf add image",
    "body": [
      "rect = fitz.Rect($1, $2, $3, $4)",
      "page.insert_image(rect, filename='$5')"
    ],
    "description": "Ajouter une image à une page PDF"
  },
  "pdf_extract_annotations": {
    "prefix": ".pdf extract annotations",
    "body": [
      "annotations = []",
      "for annot in page.annots():",
      "    annotations.append(annot.info)",
      "print(annotations)"
    ],
    "description": "Extraire les annotations d'une page PDF"
  },
  "pdf_redact": {
    "prefix": ".pdf redact",
    "body": [
      "areas = page.search_for('$1')",
      "for area in areas:",
      "    page.add_redact_annot(area, text='$2', fill=(0, 0, 0))",
      "page.apply_redactions()"
    ],
    "description": "Rédiger du texte dans un PDF"
  },
  "pdf_add_link": {
    "prefix": ".pdf add link",
    "body": [
      "page.insert_link({'kind': fitz.LINK_URI, 'from': ($1, $2, $3, $4), 'uri': '$5'})"
    ],
    "description": "Ajouter un lien hypertexte à une page PDF"
  },
  "pdf_add_bookmark": {
    "prefix": ".pdf add bookmark",
    "body": [
      "doc[0].add_bookmark($1, $2)"
    ],
    "description": "Ajouter un signet à un PDF"
  },
  "pdf_remove_bookmark": {
    "prefix": ".pdf remove bookmark",
    "body": [
      "doc[0].delete_bookmark($1)"
    ],
    "description": "Supprimer un signet d'un PDF"
  },
  "pdf_add_watermark": {
    "prefix": ".pdf add watermark",
    "body": [
      "page.insert_text(($1, $2), '$3', fontsize=$4, color=($5, $6, $7), rotate=$8)"
    ],
    "description": "Ajouter un filigrane à une page PDF"
  },
  "pdf_add_signature": {
    "prefix": ".pdf add signature",
    "body": [
      "page.insert_image(($1, $2), filename='$3')"
    ],
    "description": "Ajouter une signature à une page PDF"
  },
  "pdf_add_background": {
    "prefix": ".pdf add background",
    "body": [
      "page.insert_image(($1, $2), filename='$3', overlay=True)"
    ],
    "description": "Ajouter un arrière-plan à une page PDF"
  },
  "io_read_file": {
    "prefix": ".io read file",
    "body": [
      "with open('$1', 'r') as file:",
      "    content = file.read()",
      "    print(content)"
    ],
    "description": "Lire le contenu d'un fichier"
  },
  "io_write_file": {
    "prefix": ".io write file",
    "body": [
      "with open('$1', 'w') as file:",
      "    file.write('$2')"
    ],
    "description": "Écrire dans un fichier"
  },
  "io_append_file": {
    "prefix": ".io append file",
    "body": [
      "with open('$1', 'a') as file:",
      "    file.write('$2')"
    ],
    "description": "Ajouter du contenu à un fichier"
  },
  "io_read_lines": {
    "prefix": ".io read lines",
    "body": [
      "with open('$1', 'r') as file:",
      "    lines = file.readlines()",
      "    for line in lines:",
      "        print(line.strip())"
    ],
    "description": "Lire un fichier ligne par ligne"
  },
  "io_write_lines": {
    "prefix": ".io write lines",
    "body": [
      "with open('$1', 'w') as file:",
      "    file.writelines($2)"
    ],
    "description": "Écrire plusieurs lignes dans un fichier"
  },
  "io_check_file_exists": {
    "prefix": ".io check file exists",
    "body": [
      "import os",
      "if os.path.exists('$1'):",
      "    print('Le fichier existe')",
      "else:",
      "    print('Le fichier n'existe pas')"
    ],
    "description": "Vérifier si un fichier existe"
  },
  "io_delete_file": {
    "prefix": ".io delete file",
    "body": [
      "import os",
      "if os.path.exists('$1'):",
      "    os.remove('$1')",
      "else:",
      "    print('Le fichier n'existe pas')"
    ],
    "description": "Supprimer un fichier"
  },
  "io_create_directory": {
    "prefix": ".io create directory",
    "body": [
      "import os",
      "os.makedirs('$1', exist_ok=True)"
    ],
    "description": "Créer un répertoire"
  },
  "io_list_directory": {
    "prefix": ".io list directory",
    "body": [
      "import os",
      "files = os.listdir('$1')",
      "for file in files:",
      "    print(file)"
    ],
    "description": "Lister les fichiers dans un répertoire"
  },
  "io_copy_file": {
    "prefix": ".io copy file",
    "body": [
      "import shutil",
      "shutil.copy('$1', '$2')"
    ],
    "description": "Copier un fichier"
  },
  "io_move_file": {
    "prefix": ".io move file",
    "body": [
      "import shutil",
      "shutil.move('$1', '$2')"
    ],
    "description": "Déplacer un fichier"
  },
  "io_rename_file": {
    "prefix": ".io rename file",
    "body": [
      "import os",
      "os.rename('$1', '$2')"
    ],
    "description": "Renommer un fichier"
  },
  "io_get_file_size": {
    "prefix": ".io get file size",
    "body": [
      "import os",
      "size = os.path.getsize('$1')",
      "print(f'Taille du fichier : {size} octets')"
    ],
    "description": "Obtenir la taille d'un fichier"
  },
  "io_read_binary": {
    "prefix": ".io read binary",
    "body": [
      "with open('$1', 'rb') as file:",
      "    content = file.read()",
      "    print(content)"
    ],
    "description": "Lire un fichier en mode binaire"
  },
  "io_write_binary": {
    "prefix": ".io write binary",
    "body": [
      "with open('$1', 'wb') as file:",
      "    file.write($2)"
    ],
    "description": "Écrire dans un fichier en mode binaire"
  },
  "sys_import": {
    "prefix": ".sys import",
    "body": [
      "import sys"
    ],
    "description": "Importer le module sys"
  },
  "sys_exit": {
    "prefix": ".sys exit",
    "body": [
      "sys.exit($1)"
    ],
    "description": "Quitter le programme avec sys.exit()"
  },
  "sys_argv": {
    "prefix": ".sys argv",
    "body": [
      "args = sys.argv",
      "print('Arguments:', args)"
    ],
    "description": "Accéder aux arguments de la ligne de commande"
  },
  "sys_path": {
    "prefix": ".sys path",
    "body": [
      "sys.path.append('$1')",
      "print('Chemins:', sys.path)"
    ],
    "description": "Ajouter un chemin au module sys.path"
  },
  "sys_stdin": {
    "prefix": ".sys stdin",
    "body": [
      "for line in sys.stdin:",
      "    print(line.strip())"
    ],
    "description": "Lire l'entrée standard avec sys.stdin"
  },
  "sys_stdout": {
    "prefix": ".sys stdout",
    "body": [
      "sys.stdout.write('$1\\n')"
    ],
    "description": "Écrire dans la sortie standard avec sys.stdout"
  },
  "sys_stderr": {
    "prefix": ".sys stderr",
    "body": [
      "sys.stderr.write('$1\\n')"
    ],
    "description": "Écrire dans la sortie d'erreur standard avec sys.stderr"
  },
  "sys_version": {
    "prefix": ".sys version",
    "body": [
      "print('Version de Python:', sys.version)"
    ],
    "description": "Afficher la version de Python"
  },
  "sys_platform": {
    "prefix": ".sys platform",
    "body": [
      "print('Plateforme:', sys.platform)"
    ],
    "description": "Afficher la plateforme actuelle"
  },
  "sys_getsizeof": {
    "prefix": ".sys getsizeof",
    "body": [
      "size = sys.getsizeof($1)",
      "print('Taille en octets:', size)"
    ],
    "description": "Obtenir la taille d'un objet en octets"
  },
  "sys_excepthook": {
    "prefix": ".sys excepthook",
    "body": [
      "def custom_excepthook(exc_type, exc_value, exc_traceback):",
      "    print('Erreur:', exc_value)",
      "",
      "sys.excepthook = custom_excepthook"
    ],
    "description": "Personnaliser le gestionnaire d'exceptions"
  },
  "sys_setrecursionlimit": {
    "prefix": ".sys setrecursionlimit",
    "body": [
      "sys.setrecursionlimit($1)"
    ],
    "description": "Définir la limite de récursion"
  },
  "sys_getrecursionlimit": {
    "prefix": ".sys getrecursionlimit",
    "body": [
      "limit = sys.getrecursionlimit()",
      "print('Limite de récursion:', limit)"
    ],
    "description": "Obtenir la limite de récursion"
  },
  "sys_getfilesystemencoding": {
    "prefix": ".sys getfilesystemencoding",
    "body": [
      "encoding = sys.getfilesystemencoding()",
      "print('Encodage du système de fichiers:', encoding)"
    ],
    "description": "Obtenir l'encodage du système de fichiers"
  },
  "sys_getdefaultencoding": {
    "prefix": ".sys getdefaultencoding",
    "body": [
      "encoding = sys.getdefaultencoding()",
      "print('Encodage par défaut:', encoding)"
    ],
    "description": "Obtenir l'encodage par défaut"
  },
  "sys_getrefcount": {
    "prefix": ".sys getrefcount",
    "body": [
      "count = sys.getrefcount($1)",
      "print('Nombre de références:', count)"
    ],
    "description": "Obtenir le nombre de références d'un objet"
  },
  "webbrowser_open": {
    "prefix": ".webbrowser open",
    "body": [
      "import webbrowser",
      "webbrowser.open('$1')"
    ],
    "description": "Ouvrir une URL dans le navigateur par défaut"
  },
  "webbrowser_open_new": {
    "prefix": ".webbrowser open new",
    "body": [
      "import webbrowser",
      "webbrowser.open_new('$1')"
    ],
    "description": "Ouvrir une nouvelle fenêtre du navigateur avec une URL"
  },
  "webbrowser_open_new_tab": {
    "prefix": ".webbrowser open new tab",
    "body": [
      "import webbrowser",
      "webbrowser.open_new_tab('$1')"
    ],
    "description": "Ouvrir une nouvelle tabulation du navigateur avec une URL"
  },
  "webbrowser_get": {
    "prefix": ".webbrowser get",
    "body": [
      "import webbrowser",
      "browser = webbrowser.get('$1')",
      "browser.open('$2')"
    ],
    "description": "Obtenir un contrôleur de navigateur spécifique"
  },
  "webbrowser_register": {
    "prefix": ".webbrowser register",
    "body": [
      "import webbrowser",
      "webbrowser.register('$1', None, webbrowser.BackgroundBrowser('$2'))"
    ],
    "description": "Enregistrer un nouveau contrôleur de navigateur"
  },
  "webbrowser_open_with_browser": {
    "prefix": ".webbrowser open with browser",
    "body": [
      "import webbrowser",
      "webbrowser.get('$1').open('$2')"
    ],
    "description": "Ouvrir une URL avec un navigateur spécifique"
  },
  "webbrowser_open_with_new": {
    "prefix": ".webbrowser open with new",
    "body": [
      "import webbrowser",
      "webbrowser.get('$1').open_new('$2')"
    ],
    "description": "Ouvrir une nouvelle fenêtre avec un navigateur spécifique"
  },
  "webbrowser_open_with_new_tab": {
    "prefix": ".webbrowser open with new tab",
    "body": [
      "import webbrowser",
      "webbrowser.get('$1').open_new_tab('$2')"
    ],
    "description": "Ouvrir une nouvelle tabulation avec un navigateur spécifique"
  },

  "subprocess_run": {
    "prefix": ".subprocess run",
    "body": [
      "import subprocess",
      "result = subprocess.run(['$1'], capture_output=True, text=True)",
      "print(result.stdout)"
    ],
    "description": "Exécuter une commande avec subprocess.run"
  },
  "subprocess_popen": {
    "prefix": ".subprocess popen",
    "body": [
      "import subprocess",
      "process = subprocess.Popen(['$1'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
      "stdout, stderr = process.communicate()",
      "print(stdout.decode())"
    ],
    "description": "Exécuter une commande avec subprocess.Popen"
  },
  "subprocess_check_output": {
    "prefix": ".subprocess check output",
    "body": [
      "import subprocess",
      "output = subprocess.check_output(['$1'], text=True)",
      "print(output)"
    ],
    "description": "Exécuter une commande et capturer la sortie avec subprocess.check_output"
  },
  "subprocess_call": {
    "prefix": ".subprocess call",
    "body": [
      "import subprocess",
      "return_code = subprocess.call(['$1'])",
      "print('Return code:', return_code)"
    ],
    "description": "Exécuter une commande avec subprocess.call"
  },
  "subprocess_run_with_env": {
    "prefix": ".subprocess run env",
    "body": [
      "import subprocess",
      "import os",
      "env = os.environ.copy()",
      "env['$1'] = '$2'",
      "result = subprocess.run(['$3'], env=env, capture_output=True, text=True)",
      "print(result.stdout)"
    ],
    "description": "Exécuter une commande avec des variables d'environnement personnalisées"
  },
  "subprocess_run_with_input": {
    "prefix": ".subprocess run input",
    "body": [
      "import subprocess",
      "result = subprocess.run(['$1'], input='$2', text=True, capture_output=True)",
      "print(result.stdout)"
    ],
    "description": "Exécuter une commande avec une entrée standard"
  },
  "subprocess_run_with_timeout": {
    "prefix": ".subprocess run timeout",
    "body": [
      "import subprocess",
      "try:",
      "    result = subprocess.run(['$1'], timeout=$2, capture_output=True, text=True)",
      "    print(result.stdout)",
      "except subprocess.TimeoutExpired:",
      "    print('La commande a expiré')"
    ],
    "description": "Exécuter une commande avec un délai d'attente"
  },
  "subprocess_run_with_shell": {
    "prefix": ".subprocess run shell",
    "body": [
      "import subprocess",
      "result = subprocess.run('$1', shell=True, capture_output=True, text=True)",
      "print(result.stdout)"
    ],
    "description": "Exécuter une commande dans un shell"
  },
  "subprocess_run_with_redirect": {
    "prefix": ".subprocess run redirect",
    "body": [
      "import subprocess",
      "with open('$1', 'w') as outfile:",
      "    subprocess.run(['$2'], stdout=outfile)"
    ],
    "description": "Rediriger la sortie d'une commande vers un fichier"
  },
  "hashlib_import": {
    "prefix": ".hashlib import",
    "body": [
      "import hashlib"
    ],
    "description": "Importer la bibliothèque hashlib"
  },
  "hashlib_md5": {
    "prefix": ".hashlib md5",
    "body": [
      "import hashlib",
      "hash_object = hashlib.md5('$1'.encode())",
      "print(hash_object.hexdigest())"
    ],
    "description": "Générer un hash MD5"
  },
  "hashlib_sha1": {
    "prefix": ".hashlib sha1",
    "body": [
      "import hashlib",
      "hash_object = hashlib.sha1('$1'.encode())",
      "print(hash_object.hexdigest())"
    ],
    "description": "Générer un hash SHA-1"
  },
  "hashlib_sha256": {
    "prefix": ".hashlib sha256",
    "body": [
      "import hashlib",
      "hash_object = hashlib.sha256('$1'.encode())",
      "print(hash_object.hexdigest())"
    ],
    "description": "Générer un hash SHA-256"
  },
  "hashlib_sha512": {
    "prefix": ".hashlib sha512",
    "body": [
      "import hashlib",
      "hash_object = hashlib.sha512('$1'.encode())",
      "print(hash_object.hexdigest())"
    ],
    "description": "Générer un hash SHA-512"
  },
  "hashlib_file_hash": {
    "prefix": ".hashlib file hash",
    "body": [
      "import hashlib",
      "with open('$1', 'rb') as file:",
      "    hash_object = hashlib.$2()",
      "    while chunk := file.read(8192):",
      "        hash_object.update(chunk)",
      "    print(hash_object.hexdigest())"
    ],
    "description": "Générer un hash pour un fichier"
  },
  "hashlib_compare_hash": {
    "prefix": ".hashlib compare hash",
    "body": [
      "import hashlib",
      "hash_object1 = hashlib.$1('$2'.encode())",
      "hash_object2 = hashlib.$3('$4'.encode())",
      "if hash_object1.hexdigest() == hash_object2.hexdigest():",
      "    print('Les hashes sont identiques')",
      "else:",
      "    print('Les hashes sont différents')"
    ],
    "description": "Comparer deux hashes"
  },
  "virtualenv_create": {
    "prefix": ".env create",
    "body": [
      "python -m venv $1"
    ],
    "description": "Créer un environnement virtuel"
  },
  "virtualenv_activate": {
    "prefix": ".env activate",
    "body": [
      "source $1/bin/activate"
    ],
    "description": "Activer un environnement virtuel (Linux/Mac)"
  },
  "virtualenv_activate_windows": {
    "prefix": ".env activate windows",
    "body": [
      "$1\\Scripts\\activate"
    ],
    "description": "Activer un environnement virtuel (Windows)"
  },
  "virtualenv_deactivate": {
    "prefix": ".env deactivate",
    "body": [
      "deactivate"
    ],
    "description": "Désactiver un environnement virtuel"
  },
  "virtualenv_install_requirements": {
    "prefix": ".env install requirements",
    "body": [
      "pip install -r requirements.txt"
    ],
    "description": "Installer les dépendances depuis un fichier requirements.txt"
  },
  "virtualenv_freeze_requirements": {
    "prefix": ".env freeze requirements",
    "body": [
      "pip freeze > requirements.txt"
    ],
    "description": "Générer un fichier requirements.txt"
  },
  "virtualenv_remove": {
    "prefix": ".env remove",
    "body": [
      "rm -rf $1"
    ],
    "description": "Supprimer un environnement virtuel (Linux/Mac)"
  },
  "virtualenv_remove_windows": {
    "prefix": ".env remove windows",
    "body": [
      "rmdir /s /q $1"
    ],
    "description": "Supprimer un environnement virtuel (Windows)"
  },
  "sqlite_connect": {
    "prefix": ".sqlite connect",
    "body": [
      "import sqlite3",
      "connection = sqlite3.connect('$1.db')",
      "cursor = connection.cursor()"
    ],
    "description": "Se connecter à une base de données SQLite"
  },
  "sqlite_create_table": {
    "prefix": ".sqlite create table",
    "body": [
      "cursor.execute('''",
      "CREATE TABLE $1 (",
      "    $2 $3,",
      "    $4 $5",
      ")",
      "''')",
      "connection.commit()"
    ],
    "description": "Créer une table dans SQLite"
  },
  "sqlite_insert": {
    "prefix": ".sqlite insert",
    "body": [
      "cursor.execute('''",
      "INSERT INTO $1 ($2) VALUES ($3)",
      "''')",
      "connection.commit()"
    ],
    "description": "Insérer des données dans une table SQLite"
  },
  "sqlite_select": {
    "prefix": ".sqlite select",
    "body": [
      "cursor.execute('''",
      "SELECT $1 FROM $2 WHERE $3",
      "''')",
      "result = cursor.fetchall()",
      "for row in result:",
      "    print(row)"
    ],
    "description": "Sélectionner des données dans une table SQLite"
  },
  "sqlite_update": {
    "prefix": ".sqlite update",
    "body": [
      "cursor.execute('''",
      "UPDATE $1 SET $2 = $3 WHERE $4",
      "''')",
      "connection.commit()"
    ],
    "description": "Mettre à jour des données dans une table SQLite"
  },
  "sqlite_delete": {
    "prefix": ".sqlite delete",
    "body": [
      "cursor.execute('''",
      "DELETE FROM $1 WHERE $2",
      "''')",
      "connection.commit()"
    ],
    "description": "Supprimer des données dans une table SQLite"
  },
  "sqlite_drop_table": {
    "prefix": ".sqlite drop table",
    "body": [
      "cursor.execute('''",
      "DROP TABLE IF EXISTS $1",
      "''')",
      "connection.commit()"
    ],
    "description": "Supprimer une table dans SQLite"
  },
  "sqlite_close": {
    "prefix": ".sqlite close",
    "body": [
      "cursor.close()",
      "connection.close()"
    ],
    "description": "Fermer la connexion à la base de données SQLite"
  },
  "sqlite_backup": {
    "prefix": ".sqlite backup",
    "body": [
      "import shutil",
      "shutil.copy('$1.db', '$2.db')"
    ],
    "description": "Sauvegarder une base de données SQLite"
  },
  "sqlite_restore": {
    "prefix": ".sqlite restore",
    "body": [
      "import shutil",
      "shutil.copy('$1.db', '$2.db')"
    ],
    "description": "Restaurer une base de données SQLite"
  },
  "sqlite_execute_script": {
    "prefix": ".sqlite execute script",
    "body": [
      "with open('$1.sql', 'r') as file:",
      "    script = file.read()",
      "cursor.executescript(script)"
    ],
    "description": "Exécuter un script SQL dans SQLite"
  },
  "sqlite_transaction": {
    "prefix": ".sqlite transaction",
    "body": [
      "try:",
      "    connection.execute('BEGIN')",
      "    cursor.execute('''",
      "    INSERT INTO $1 ($2) VALUES ($3)",
      "    ''')",
      "    connection.commit()",
      "except Exception as e:",
      "    connection.rollback()",
      "    print('Erreur:', e)"
    ],
    "description": "Gérer une transaction dans SQLite"
  },
  "sqlite_pragma": {
    "prefix": ".sqlite pragma",
    "body": [
      "cursor.execute('''",
      "PRAGMA $1 = $2",
      "''')"
    ],
    "description": "Exécuter une commande PRAGMA dans SQLite"
  },
  "sqlite_foreign_key": {
    "prefix": ".sqlite foreign key",
    "body": [
      "cursor.execute('''",
      "PRAGMA foreign_keys = ON",
      "''')"
    ],
    "description": "Activer les clés étrangères dans SQLite"
  }
}
